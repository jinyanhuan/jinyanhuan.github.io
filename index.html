<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>code_bunny&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="never giveup reading!">
<meta property="og:type" content="website">
<meta property="og:title" content="code_bunny's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="code_bunny's blog">
<meta property="og:description" content="never giveup reading!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="code_bunny's blog">
<meta name="twitter:description" content="never giveup reading!">
  
    <link rel="alternative" href="/atom.xml" title="code_bunny&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="https://avatars1.githubusercontent.com/u/11350373?v=3&amp;s=460">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">code_bunny</a></h1>
		</hgroup>

		
		<p class="header-subtitle">never giveup reading!</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/OOP-Code-Bunny/" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/p/1005052438739075/home" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/es5/" style="font-size: 10px;">es5</a> <a href="/tags/github/" style="font-size: 20px;">github</a> <a href="/tags/grunt/" style="font-size: 10px;">grunt</a> <a href="/tags/hexo/" style="font-size: 20px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/less/" style="font-size: 10px;">less</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/sass/" style="font-size: 10px;">sass</a> <a href="/tags/webstorm/" style="font-size: 15px;">webstorm</a> <a href="/tags/前端工程化/" style="font-size: 10px;">前端工程化</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/OOP-Code-Bunny/">我的github</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/a5635268/">周孝刚</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://kingarthas37.github.io/">王麟</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/zhengyin/">郑印</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">虽然咸鱼翻身还是咸鱼,但至少可以变得好吃一点</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">code_bunny</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://avatars1.githubusercontent.com/u/11350373?v=3&amp;s=460">
				<hgroup>
				  <h1 class="header-author">code_bunny</h1>
				</hgroup>
			</div>
			
			<p class="header-subtitle">never giveup reading!</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/OOP-Code-Bunny/" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/p/1005052438739075/home" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Object-defineProperty-方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/27/Object-defineProperty-方法/" class="article-date">
  	<time datetime="2016-01-27T07:26:50.000Z" itemprop="datePublished">2016-01-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/27/Object-defineProperty-方法/">Object.defineProperty()方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Object-defineProperty()方法详解">Object.defineProperty()方法详解</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_Setters_and_Getters" target="_blank" rel="external">查看原文</a></p>
<p><em>Object.defineProperty()</em> 方法可以直接给对象定义一个新的属性, 或者修改对象上已存在的某个属性, 最后返回这个对象.</p>
<h2 id="语法">语法</h2><blockquote>
<p>Object.defineProperty(obj, prop, descriptor)</p>
</blockquote>
<h3 id="Parameters">Parameters</h3><p><strong>obj</strong><br>需要被定义属性的对象</p>
<p><strong>prop</strong><br>需要被定义(或修改)的属性名</p>
<p><strong>descriptor</strong><br>对需要被定义(或修改)的属性的描述</p>
<h2 id="介绍">介绍</h2><p>这个方法允许精确的添加或修改对象的属性.通过普通的分配方式给对象添加的属性,会在对象属性被枚举时展示(比如<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="external">for in</a>循环或者使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="external">Object.keys</a>),它的值也可以被修改,被<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete" target="_blank" rel="external">delete</a>.这个方法允许你通过更详细的配置来修改这些默认的行为. 默认情况下,通过 <code>Object.defineProperty()</code> 定义的属性值是不可变的.</p>
<p>对象的属性的描述符(即descriptor参数)有两种方式定义: 数据描述符(<strong>data descriptor</strong>)和存取器描述符(<strong>accessor descriptor</strong>).<br><strong>数据描述符</strong>表示:这个属性有一个值,这个值可以是可写的,也可以是不可写的.<br><strong>存取器描述符</strong>表示:这个属性有一对函数,一个是获取函数,一个是设置函数(getter&amp;setter);<br>描述符必须是这两者之一,不能都有.</p>
<p>数据描述符和存取器描述符都是对象. 他们都需要下列属性:</p>
<p><strong>configurable</strong><br><code>true</code>: 当且仅当描述符可以被修改并且属性可以从相应的对象中被删除的时候<br><strong>默认是</strong><code>false</code>.</p>
<p><strong>enumerable</strong><br><code>true</code>: 当且仅当这个属性需要在对象属性被枚举的时候被展示出来.<br><strong>默认是</strong><code>false</code>.</p>
<p>数据描述符还拥有下列可选的属性:</p>
<p><strong>value</strong><br>属性对应的值.可以是任何有效的Javascript值(数值,对象,函数,等等).<br><strong>默认是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="external">undefined</a></strong>.</p>
<p><strong>writable</strong><br><code>true</code>: 当且仅当属性的值可以通过赋值操作而被改变时.<br><strong>默认是</strong><code>false</code></p>
<p>存取器描述符还拥有下列可选的属性:</p>
<p><strong>get</strong><br>一个函数,它是属性的获取函数.如果没有定义获取函数,它就是undefined.函数的返回值就会成为这个属性的值.<br><strong>默认是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="external">undefined</a></strong>.</p>
<p><strong>set</strong><br>一个函数,它是属性的设置函数,如果没有定义设置函数,它就是undefined.当属性值被赋值(通过普通方式)的时候,这个新值会被作为唯一的参数传入.<br><strong>默认是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="external">undefined</a></strong>.</p>
<p>记住,上面这些选项不一定要是对象自身的属性,所以还需要考虑是否被继承的问题.为了确保在不写这些选项时,它取到的是默认值,你需要预先冻结<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="external">Object.prototype</a>. 所以,明确的指定每个选项,或者把 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="external">__proto__</a> 属性指定为 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="external">null</a>.</p>
<pre><code><span class="comment">// 冻结 __proto__</span>
<span class="keyword">var</span> obj = {};
<span class="built_in">Object</span>.defineProperty(obj, <span class="string">'key'</span>, {
  __proto__: <span class="literal">null</span>, <span class="comment">// no inherited properties</span>
  value: <span class="string">'static'</span>  <span class="comment">// not enumerable</span>
                   <span class="comment">// not configurable</span>
                   <span class="comment">// not writable</span>
                   <span class="comment">// as defaults</span>
});

<span class="comment">// 明确指定每个选项值</span>
<span class="built_in">Object</span>.defineProperty(obj, <span class="string">'key'</span>, {
  enumerable: <span class="literal">false</span>,
  configurable: <span class="literal">false</span>,
  writable: <span class="literal">false</span>,
  value: <span class="string">'static'</span>
});

<span class="comment">// 重用同一个对象</span>
<span class="function"><span class="keyword">function</span> <span class="title">withValue</span>(<span class="params">value</span>) </span>{
  <span class="keyword">var</span> d = withValue.d || (
    withValue.d = {
      enumerable: <span class="literal">false</span>,
      writable: <span class="literal">false</span>,
      configurable: <span class="literal">false</span>,
      value: <span class="literal">null</span>
    }
  );
  d.value = value;
  <span class="keyword">return</span> d;
}
<span class="comment">// ... 然后 ...</span>
<span class="built_in">Object</span>.defineProperty(obj, <span class="string">'key'</span>, withValue(<span class="string">'static'</span>));

<span class="comment">// 如果freeze方法是可用的,阻止对对象 prototype 属性进行新增或删除.(value, get, set, enumerable, writable, configurable)   </span>
(<span class="built_in">Object</span>.freeze || <span class="built_in">Object</span>)(<span class="built_in">Object</span>.prototype);
</code></pre><h2 id="Examples">Examples</h2><p>如果你想知道如何使用<strong>二进制标识风格</strong>句法来使用 Object.defineProperty 方法,查看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples" target="_blank" rel="external">额外例子</a> (这个好恶心…━┳━　━┳━)</p>
<h3 id="新建一个属性">新建一个属性</h3><p>当对象里没有既存的指定属性时,<code>Object.defineProperty()</code>方法会按照描述创建一个新的属性.描述符里的所有选项都可以省略,被省略的选项会取默认值.所有的布尔值都默认为<code>false</code>. <code>value</code>,<code>get</code>,<code>set</code>选项默认是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="external">undefined</a>.如果一个属性,它的描述符里没有 <code>get/set/value/writable</code> 这些选项,它被称为 ‘通用型(generic)’, 并且被归类到数据描述符. </p>
<pre><code><span class="keyword">var</span> o = {}; <span class="comment">// 创建一个新的对象</span>

<span class="comment">// 一个通过数据描述符,使用defineProperty来添加属性的例子</span>
Object.defineProperty(o, <span class="string">'a'</span>, {
  value: <span class="number">37</span>,
  writable: <span class="literal">true</span>,
  enumerable: <span class="literal">true</span>,
  configurable: <span class="literal">true</span>
});

<span class="comment">// 'a' 属性存在于 o 对象中,它的值是37 </span>

<span class="comment">// 一个通过存取器描述符,使用defineProperty来添加属性的例子 </span>
<span class="keyword">var</span> bValue = <span class="number">38</span>;
Object.defineProperty(o, <span class="string">'b'</span>, {
  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{ <span class="keyword">return</span> bValue; },
  <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span> </span>{ bValue = newValue; },
  enumerable: <span class="literal">true</span>,
  configurable: <span class="literal">true</span>
});
o.b; <span class="comment">// 38</span>
<span class="comment">// 'b' 属性存在于 o 对象中,它的值是38</span>
<span class="comment">// 现在, o.b的值永远等于bValue,除非重新定义o.b</span>

<span class="comment">// 你不能尝试结合两者:</span>
Object.defineProperty(o, <span class="string">'conflict'</span>, {
  value: <span class="number">0x9f91102</span>,
  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="number">0xdeadbeef</span>; }
});
<span class="comment">// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors</span>
</code></pre><blockquote>
<p>补充说一下这里的set选项,get选项很简单,就是通过这个函数来获取对象对应的属性值,而set函数,是当你使用 <code>.</code> 操作符来给属性分配值的时候被调用的. 需要注意的是,当使用 <code>.</code> 操作符来给属性分配值的时候,先调用 setter ,然后还会调用 getter.考虑以下代码:</p>
</blockquote>
<pre><code>Object.defineProperty(o, <span class="string">'b'</span>, {
  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{ <span class="keyword">return</span> bValue; },
  <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span> </span>{ bValue = newValue+<span class="number">1</span>; },
  enumerable: <span class="literal">true</span>,
  configurable: <span class="literal">true</span>
});
o.b; <span class="comment">// 38</span>
o.b = <span class="number">39</span>;
console.log(o.b) <span class="comment">//40</span>
</code></pre><blockquote>
<p>当使用 <code>o.b = 39</code> 来给对象分配属性值时, 首先调用 setter ,然后调用 getter, 而o.b最终的值,依然是 getter 得到的结果. </p>
</blockquote>
<h3 id="修改属性">修改属性</h3><p>当属性已经存在, <code>Object.defineProperty()</code> 会尝试根据描述符里的值和对象目前的配置来修改这个属性. 如果原来的描述符里,<code>configurable</code> 属性被设置为 <code>false</code> (代表这个属性不能被配置),那么,除了<code>writable</code>之外的所有属性都不能被修改.在这样的情况下,也不能切换描述符的类型,不能把数据描述符改成存取器描述符,反之也不能.</p>
<p>如果一个属性是不可配置的,它的 <code>writable</code> 属性只能被修改成 <code>false</code>.</p>
<p>尝试修改一个不可配置的属性(除了 <code>writable</code>),除非修改后的值和原来一样,否则会抛出一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError" target="_blank" rel="external">TypeError</a> .</p>
<h4 id="Writable_属性">Writable 属性</h4><p>当 <code>writable</code> 属性被设置为 <code>false</code> 的时候, 表示这个属性是不可写的. 它不能被重定义值.</p>
<pre><code>var o = {}; <span class="comment">// 创建一个新的对象</span>

Object.defineProperty(o, <span class="string">'a'</span>, {
  value: <span class="number">37</span>,
  writable: <span class="literal">false</span>
});

console.<span class="built_in">log</span>(o.a); <span class="comment">// 打印出 37</span>
o.a = <span class="number">25</span>; <span class="comment">// 不会报错(如果是在严格模式下还是会报错,即使你定义的值和原来一样,也会报错)</span>
console.<span class="built_in">log</span>(o.a); <span class="comment">// 打印出 37. 之前的定义没有生效</span>
</code></pre><p>就如这个栗子所见, 尝试写入一个不可写的属性不会生效,但也不会报错</p>
<blockquote>
<p>虽然不能重写,但是是否可以删除取决于<code>configurable</code>,而不是<code>writable</code></p>
</blockquote>
<h4 id="Enumerable_属性">Enumerable 属性</h4><p><code>enumerable</code> 属性定义了对象属性在使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="external">for…in</a>循环或者<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="external">Object.keys()</a>枚举时是否被展示</p>
<pre><code><span class="keyword">var</span> o = {};
<span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, { value: <span class="number">1</span>, enumerable: <span class="literal">true</span> });
<span class="built_in">Object</span>.defineProperty(o, <span class="string">'b'</span>, { value: <span class="number">2</span>, enumerable: <span class="literal">false</span> });
<span class="built_in">Object</span>.defineProperty(o, <span class="string">'c'</span>, { value: <span class="number">3</span> }); <span class="comment">// enumerable 默认为false</span>
o.d = <span class="number">4</span>; <span class="comment">// 使用这种方式设置的时候,enumerable 默认为true</span>

<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> o) {
  <span class="built_in">console</span>.log(i);
}
<span class="comment">// 打印出 'a' 和 'd' (in undefined order)</span>

<span class="built_in">Object</span>.keys(o); <span class="comment">// ['a', 'd']</span>

o.propertyIsEnumerable(<span class="string">'a'</span>); <span class="comment">// true</span>
o.propertyIsEnumerable(<span class="string">'b'</span>); <span class="comment">// false</span>
o.propertyIsEnumerable(<span class="string">'c'</span>); <span class="comment">// false</span>
</code></pre><h4 id="Configurable_属性">Configurable 属性</h4><p><code>configurable</code> 同时控制了该属性是否能从对象中被删除,以及(描述符里的)属性(除了<code>writable</code>)是否可以被修改.</p>
<pre><code><span class="keyword">var</span> o = {};
<span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, {
  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> <span class="number">1</span>; },
  configurable: <span class="literal">false</span>
});

<span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, { configurable: <span class="literal">true</span> }); <span class="comment">// throws a TypeError</span>
<span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, { enumerable: <span class="literal">true</span> }); <span class="comment">// throws a TypeError</span>
<span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, { set: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{} }); <span class="comment">// throws a TypeError (set属性值之前是undefined)</span>
<span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, { get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> <span class="number">1</span>; } }); <span class="comment">// throws a TypeError (即使新的函数做的事情和原来的一模一样)</span>
<span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, { value: <span class="number">12</span> }); <span class="comment">// throws a TypeError</span>

<span class="built_in">console</span>.log(o.a); <span class="comment">// logs 1</span>
<span class="keyword">delete</span> o.a; <span class="comment">// 什么也没发生</span>
<span class="built_in">console</span>.log(o.a); <span class="comment">// logs 1</span>
</code></pre><p>如果 <code>o.a</code> 的 <code>configurable</code> 属性被设置为 <code>true</code> , 以上报错都不会有,最后这个属性会被删除.</p>
<h3 id="添加对象属性时的默认值">添加对象属性时的默认值</h3><p>有一个重要的事需要被考虑到:在你为对象添加属性的时候,属性的默认属性是怎么样的.通常来说,简单地使用 <code>.</code> 操作符和使用 <code>Object.defineProperty()</code> 来分配属性值是有区别的,如下栗子所示:</p>
<pre><code>var o = {};

o.a = <span class="number">1</span>;
<span class="comment">// 也可以写成:</span>
Object.defineProperty(o, <span class="string">'a'</span>, {
  value: <span class="number">1</span>,
  writable: <span class="literal">true</span>,
  configurable: <span class="literal">true</span>,
  enumerable: <span class="literal">true</span>
});


<span class="comment">// 另外,</span>
Object.defineProperty(o, <span class="string">'a'</span>, { value: <span class="number">1</span> });
<span class="comment">// 也可以写成:</span>
Object.defineProperty(o, <span class="string">'a'</span>, {
  value: <span class="number">1</span>,
  writable: <span class="literal">false</span>,
  configurable: <span class="literal">false</span>,
  enumerable: <span class="literal">false</span>
});
</code></pre><h3 id="自定义_Setters_和_Getters">自定义 Setters 和 Getters</h3><p>下面的例子展示了如何实现一个自动存档的对象.每当温度属性被设置, 存档数组都会有相应的记录.</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Archiver</span><span class="params">()</span> </span>{
  <span class="keyword">var</span> temperature = <span class="literal">null</span>;
  <span class="keyword">var</span> archive = [];

  Object.defineProperty(<span class="keyword">this</span>, <span class="string">'temperature'</span>, {
    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
      console.log(<span class="string">'get!'</span>);
      <span class="keyword">return</span> temperature;
    },
    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>{
      temperature = value;
      archive.push({ val: temperature });
    }
  });

  <span class="keyword">this</span>.getArchive = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{ <span class="keyword">return</span> archive; };
}

<span class="keyword">var</span> arc = <span class="keyword">new</span> Archiver();
arc.temperature; <span class="comment">// 'get!'</span>
arc.temperature = <span class="number">11</span>;
arc.temperature = <span class="number">13</span>;
arc.getArchive(); <span class="comment">// [{ val: 11 }, { val: 13 }]</span>
</code></pre><h2 id="版本说明">版本说明</h2><table>
<thead>
<tr>
<th>版本</th>
<th style="text-align:center">状态</th>
<th style="text-align:right">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.2.3.6" target="_blank" rel="external">‘Object.defineProperty’方法被定义在了ECMAScript 5.1 (ECMA-262)</a></td>
<td style="text-align:center"><em>ST</em> 标准</td>
<td style="text-align:right">初次定义. 在JavaScript 1.8.5 里被实现</td>
</tr>
<tr>
<td><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-object.defineproperty" target="_blank" rel="external">‘Object.defineProperty’方法被定义在了ECMAScript 2015 (6th Edition, ECMA-262)</a></td>
<td style="text-align:center"><em>ST</em> 标准</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td><a href="https://tc39.github.io/ecma262/#sec-object.defineproperty" target="_blank" rel="external">‘Object.defineProperty’方法被定义在了ECMAScript 2016 Draft (7th Edition, ECMA-262)</a></td>
<td style="text-align:center"><em>D</em> 草案</td>
</tr>
</tbody>
</table>
<h2 id="浏览器兼容性">浏览器兼容性</h2><p><strong>桌面端</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th style="text-align:center">Firefox (Gecko)</th>
<th style="text-align:right">Chrome</th>
<th style="text-align:right">Internet Explorer</th>
<th style="text-align:right">Opera</th>
<th style="text-align:right">Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本支持</td>
<td style="text-align:center">4.0(2)</td>
<td style="text-align:right">5</td>
<td style="text-align:right">9[1]</td>
<td style="text-align:right">11.60</td>
<td style="text-align:right">5.1[2]</td>
</tr>
</tbody>
</table>
<p>[1] 在ie8下只支持DOM对象, 而且有一些非标准行为.<br>[2] Safari5 也支持, 但不支持DOM对象. </p>
<p><strong>移动端</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th style="text-align:center">Firefox Mobile (Gecko)</th>
<th style="text-align:right">Android</th>
<th style="text-align:right">IE Mobile</th>
<th style="text-align:right">Opera Mobile</th>
<th style="text-align:right">Safari Mobile</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本支持</td>
<td style="text-align:center">4.0(2)</td>
<td style="text-align:right">(支持)</td>
<td style="text-align:right">9</td>
<td style="text-align:right">11.5</td>
<td style="text-align:right">(支持)</td>
</tr>
</tbody>
</table>
<h2 id="兼容性问题补充说明">兼容性问题补充说明</h2><h3 id="重新定义数组对象的_length_属性">重新定义数组对象的 <code>length</code> 属性</h3><p>重新定义数组的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length" target="_blank" rel="external">length</a> 属性是可行的,但也受制于普通的重定义时的限制.<br>(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length" target="_blank" rel="external">length</a>属性一开始是不能配置,不可枚举,但是可写的.<br>所以,改变一个没有被修改过(描述符)的数组的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length" target="_blank" rel="external">length</a> 属性是可行的.<br>也可以把它改成不可写的,但是不允许修改它的可枚举性和可配置性.如果它已经被改成不可写的,也不能修改它的值,也不能修改它的可写性.)然而,并不是所有的浏览器都允许重定义它的.</p>
<p>如果在 Firefox 4 到 22 里尝试此操作会抛出一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError" target="_blank" rel="external">TypeError</a> , 无论它是否允许重定义数组的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length" target="_blank" rel="external">length</a> 属性. </p>
<p>某些版本的Chrome浏览器在使用 <code>Object.defineProperty()</code> 来修改数组 <code>length</code> 属性时,如果修改后的值不同于数组当前的 <code>length</code> 属性,它会忽略这次修改.<br>在某些情况下,修改它的可写性其实也没有生效(也不会报错).<br>另外,与此相关的是,一些修改数组的方法,比如 <code>Array.prototype.push</code> 却无视 <code>length</code> 属性的不可写性.(就是说,使用<code>push</code>方法,数组的<code>length</code>属性值依然会被改变,即使它是不可写的.)</p>
<p>某些版本的Safari浏览器在使用 <code>Object.defineProperty()</code> 来修改数组 <code>length</code> 属性时,如果修改后的值不同于数组当前的 <code>length</code> 属性,它会忽略这次修改,还会尝试去改变它的可写性,但最终,属性的可写性并没有被改变,这个过程也不会报错.</p>
<p>只有ie 9 及以后的版本, Firefox 23 及以后的版本, 开始完全地,正确地支持重定义数组的 <code>length</code> 属性.到目前为止,不要指望使用 <code>Object.defineProperty()</code> 重定义数组的 <code>length</code> 属性能够以一种通用的方式正常工作.而且,就算它靠得住,也没有足够的理由去这样做.</p>
<h3 id="针对ie8的特别说明">针对ie8的特别说明</h3><p>ie 8 下的 <code>Object.defineProperty()</code> 方法<a href="https://msdn.microsoft.com/en-us/library/dd229916%28VS.85%29.aspx" target="_blank" rel="external">只能被用在DOM对象</a>上.有一些事情需要注意:</p>
<ul>
<li>如果尝试在原生的对象上使用 <code>Object.defineProperty()</code> 方法,会报错.</li>
<li>定义属性时,描述符的选项必须被设置为指定的值. 如果是数据描述符,<code>configurable</code>,<code>enumerable</code>,<code>writable</code> 都必须被设置为<code>true</code>,如果是存取器描述符, <code>configurable</code> 必须是 <code>true</code>, <code>enumerable</code> 必须是 <code>false</code>, 如果设置的值不是这些,会报错.</li>
<li>重定义属性的话,需要把原来的属性给删掉.如果原来的属性没有删掉,重定义不会生效,它还是保持原来的属性.</li>
</ul>
<h3 id="看看相关内容">看看相关内容</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" target="_blank" rel="external">Enumerability and ownership of properties</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="external">Object.defineProperties()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable" target="_blank" rel="external">Object.propertyIsEnumerable()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="external">Object.getOwnPropertyDescriptor()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch" target="_blank" rel="external">Object.prototype.watch()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/unwatch" target="_blank" rel="external">Object.prototype.unwatch()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="external">get</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" target="_blank" rel="external">set</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples" target="_blank" rel="external">Additional Object.defineProperty examples</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/defineProperty" target="_blank" rel="external">Reflect.defineProperty()</a></li>
</ul>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es5/">es5</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/blog/">blog</a>
	</div>


      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-thinking-in-react" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/17/thinking-in-react/" class="article-date">
  	<time datetime="2016-01-17T05:36:22.000Z" itemprop="datePublished">2016-01-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/17/thinking-in-react/">thinking-in-react</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于React的一些思考">关于React的一些思考</h1><p>作者: Pete Hunt</p>
<p><a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="external">查看原文</a></p>
<p>在我看来,React是使用javascript构建大型快速应用的首选途径. 它在Instagram和facebook上都运行的很好.</p>
<p>React的一个重要部分就是,如何去思考你要构建的应用.在这篇文章里,我会带领你一步一步思考如何使用React来实现一个搜索产品列表的功能.</p>
<h2 id="从一个原型开始">从一个原型开始</h2><p>想象我们已经有一个JSON格式的数据文件以及一个设计师给出的原型.显然我们的设计师水平很烂,因为这个原型看起来是这样的:</p>
<p><img src="http://jinyanhuan.github.io/blogimages/20160117.01.png" alt="Mockup"></p>
<p>我们的JSON文件返回的数据是这样的:</p>
<pre><code>[
  {<span class="string">category:</span> <span class="string">"Sporting Goods"</span>, <span class="string">price:</span> <span class="string">"$49.99"</span>, <span class="string">stocked:</span> <span class="literal">true</span>, <span class="string">name:</span> <span class="string">"Football"</span>},
  {<span class="string">category:</span> <span class="string">"Sporting Goods"</span>, <span class="string">price:</span> <span class="string">"$9.99"</span>, <span class="string">stocked:</span> <span class="literal">true</span>, <span class="string">name:</span> <span class="string">"Baseball"</span>},
  {<span class="string">category:</span> <span class="string">"Sporting Goods"</span>, <span class="string">price:</span> <span class="string">"$29.99"</span>, <span class="string">stocked:</span> <span class="literal">false</span>, <span class="string">name:</span> <span class="string">"Basketball"</span>},
  {<span class="string">category:</span> <span class="string">"Electronics"</span>, <span class="string">price:</span> <span class="string">"$99.99"</span>, <span class="string">stocked:</span> <span class="literal">true</span>, <span class="string">name:</span> <span class="string">"iPod Touch"</span>},
  {<span class="string">category:</span> <span class="string">"Electronics"</span>, <span class="string">price:</span> <span class="string">"$399.99"</span>, <span class="string">stocked:</span> <span class="literal">false</span>, <span class="string">name:</span> <span class="string">"iPhone 5"</span>},
  {<span class="string">category:</span> <span class="string">"Electronics"</span>, <span class="string">price:</span> <span class="string">"$199.99"</span>, <span class="string">stocked:</span> <span class="literal">true</span>, <span class="string">name:</span> <span class="string">"Nexus 7"</span>}
];
</code></pre><h2 id="第一步:_把视图拆分成层级组件">第一步: 把视图拆分成层级组件</h2><p>首先你需要画一个盒子模型草图,这个盒子模型包括了原型里的每个组件和它的子组件,然后给每个组件取名字.如果你和设计师协作,他们可能已经帮你完成了取名这件事,直接去问他们就行.ps图层名可能就是最后React组件的名字.</p>
<p>但你怎么知道哪些应该是一个组件呢? 只需要通过判断你是否需要新建一个对象或者函数. 这个技术秉持<strong>各自负责原则</strong>,就是说,从理念上讲,一个组件只做一件事.如果它后面需要扩展,就应该被解耦成多个子组件.</p>
<p>由于大多数时候你展示给用户的数据模型都是基于JSON格式的,你会发现,一旦你的模型建立正确,你的视图(连同你的组件结构)会很好匹配它.这是因为视图和数据模型倾向于依附同一个结构.这就意味着,把视图拆分成组件是很简单的,只需要按照每个组件匹配一个数据模型来拆分就可以了.</p>
<p><img src="http://jinyanhuan.github.io/blogimages/20160117.02.png" alt="Mockup"></p>
<p>你可以看到,这个简单的应用里有5个组件.我已经用粗体字标明了每个组件代表了哪个数据模型.</p>
<ol>
<li><code>FilterableProductTable</code> <strong>(橙色)</strong>: 包含了整个栗子</li>
<li><code>SearchBar</code> <strong>(深蓝)</strong>: 接收用户输入的内容</li>
<li><code>ProductTable</code> <strong>(绿色)</strong>: 过滤并展示基于用户输入搜索条件的匹配数据.</li>
<li><code>ProductCategoryRow</code> <strong>(亮蓝)</strong>: 展示每个分类的标题.</li>
<li><code>ProductRow</code> <strong>(红色)</strong>: 将每个产品一行一行显示出来.</li>
</ol>
<p>看一下 <code>ProductTable</code>, 你会发现,表格的标题部分(包括Name和Price两项)并不是一个单独的组件.这是由个人偏好决定的,也有争议说不应该这样处理.在这个例子里,我把它作为 <code>ProductTable</code> 的一部分,因为它也是渲染搜索结果数据的一部分,这个事情应该由 <code>ProductTable</code> 负责.但是,如果这个标题变得更复杂(比如我们要添加排序功能),显然就应该把它单独做成一个 <code>ProductTableHeader</code> 组件</p>
<p>现在,我们已经给原型定义好了组件,让我们把它整理成一个层级关系.这很简单. 被包含在其他组件里的组件应该出现在层级图的子层:</p>
<p><img src="http://jinyanhuan.github.io/blogimages/20160117.03.png" alt="hierarchy"></p>
<h2 id="第二步:_使用React构建一个静态版本">第二步: 使用React构建一个静态版本</h2><p>代码在jsfiddle上:<a href="https://jsfiddle.net/reactjs/yun1vgqb/" target="_blank" rel="external">查看代码</a></p>
<p>现在你已经有了组件的层级关系,就可以开始你的应用了.最简单的方法是构建一个不带有任何交互,仅使用数据模型来渲染出视图的版本.最好能够把把这个过程进行解耦,因为构建静态版本需要打很多不用动脑筋的代码,而添加交互不需要写很多代码,却很费脑子.我们来看下这是为什么.</p>
<p>构建一个静态渲染数据模型的应用,你的组件里需要重用其他组件,然后通过 <em>props</em> 来传递数据.props用于从父组件向子组件传递数据. 如果你听说过’状态’这个概念,那么记住,<strong>不要在静态的版本里使用状态</strong>.状态是留给交互使用的,就是说,在一段时间后会改变的数据. 由于现在做的是静态版的应用,所以你用不到它.</p>
<p>你的思考方式可以是从上到下,也可以是从下到上. 就是说,你可以从层级的最高层的组件开始做(比如从<code>FilterableProductTable</code>开始)或者最底层的那个(<code>ProductRow</code>).一般来说,在简单的情况下,从上到下会比较简单,在大型的项目里,从下到上的构建并编写测试会比较简单.</p>
<p>在这一步的最后,你会得到一个可重用的组件库,用于渲染数据模型.组件只有 <code>render()</code> 方法,因为这是一个静态的版本.数据模型会被放在最外层的组件(<code>FilterableProductTable</code>)的prop属性里.如果你修改了底层的数据模型,然后再次调用 <code>ReactDOM.render()</code> 方法,视图会被更新.你可以很容易的看到视图是怎么被更新的,哪里发生了变化.因为没有什么复杂的事情发生.React的<strong>单向数据流</strong>(或称单向数据绑定)保证了页面的模块化和速度.</p>
<p>如果你在这一步有什么问题,请参考<a href="https://facebook.github.io/react/docs/" target="_blank" rel="external">React文档</a>.</p>
<h2 id="第三步:_定义视图的状态,要做到最小化但却完整-">第三步: 定义视图的状态,要做到最小化但却完整.</h2><p>要让视图实现交互,你需要触发底层数据模型发生改变.React通过状态来简单的实现了它.</p>
<p>为了正确构建你的应用,首先要思考的是,应用有哪些变化的状态,他们的最小单位应该是什么.这里的关键是 DRY(Don’t Repeat Yourself) 原则: 不要自己重复自己.</p>
<p>找出应用里所需要的最小单位的状态,而其他需要的东西,可以通过算法来实现. 举个栗子,如果你要做一个TODO列表,只需要有一个数组格式的TODOs的列表;不要给数量单独赋予一个状态,而是通过获取TODO数组的长度来得到TODOs的数量.</p>
<p>考虑这个例子里的每条数据:</p>
<ul>
<li>商品的原始列表</li>
<li>用户输入的搜索词</li>
<li>checkbox是否被选中</li>
<li>过滤出的商品列表</li>
</ul>
<p>让我们过一遍,找出哪些应该是状态.每条数据都问三个问题:</p>
<ol>
<li>它是不是通过父组件的props传入的? 如果是,那它很可能不是一个状态.</li>
<li>它过一段时间会改变么? 如果不会,那它很可能不是一个状态.</li>
<li>你可以通过计算其它状态和组件的props属性来得到它么? 如果是,那它就不是状态.</li>
</ol>
<p>商品原始列表是通过props属性传入的,所以它不是状态.搜索词和checkbox应该是状态,因为他们会发生改变,而且不能通过其它东西计算出结果.最后,过滤出的商品列表不是状态,因为它可以通过商品原始列表,搜索词,checkbox是否选中来计算出.</p>
<p>所以最后,我们的状态应该是:</p>
<ul>
<li>用户输入的搜索内容</li>
<li>checkbox的值</li>
</ul>
<h2 id="第四步:_确定状态应该放在哪里">第四步: 确定状态应该放在哪里</h2><p>代码在jsfiddle上:<a href="https://jsfiddle.net/reactjs/zafjbw1e/" target="_blank" rel="external">查看代码</a></p>
<p>很好,现在我们已经确定了应用的最小单位状态.接下来,我们需要确认哪些组件是变化的,或者说,哪些组件拥有了这些状态.</p>
<p>注意: React 是沿着组件的层级向下使用单向数据绑定的.所以不能立时片刻的搞清楚哪些组件应该拥有哪些状态.这通常也是对初学者来说理解起来最有挑战的部分,可以参考下面的步骤来找出它:</p>
<p>对于应用中的每个状态:</p>
<ul>
<li>找出哪些组件渲染时需要用到那个状态</li>
<li>找出一个公共组件 (就是包含了所有1里找到的组件的父级组件)</li>
<li>可以是2里找到的公共组件,也可以是这个公共组件的父组件</li>
<li>如果找不到这样一个应该拥有状态的组件,那就自己创建一个,这个被创建的组件仅仅用于存放状态.把这个组件放在公共组件的外层.</li>
</ul>
<p>让我们在这个应用里使用以上的策略:</p>
<ul>
<li><code>ProductTable</code> 组件需要通过状态来过滤产品列表, <code>SearchBar</code> 需要展示搜索内容和checked状态.</li>
<li>这两个组件的公共组件是 <code>FilterableProductTable</code></li>
<li>把搜索内容和checked值放在 <code>FilterableProductTable</code> 下,从概念上也是合理的.</li>
</ul>
<p>很好,现在我们已经决定了把状态放在 <code>FilterableProductTable</code> 组件上. 首先,给 <code>FilterableProductTable</code> 添加一个 <code>getInitialState()</code> 方法,返回 <code>{filter: &#39;&#39;, inStockOnly: false}</code> 来作为状态的初始值. 然后,把 <code>filterText</code> 和 <code>inStockOnly</code> 添加到 <code>ProductTable</code> 和 <code>SearchBar</code> 组件的prop属性里. 最后,通过这些属性,在 <code>ProductTable</code> 组件里过滤出内容,在 <code>SearchBar</code> 组件里设置表单控件的值.</p>
<p>现在可以开始看到应用是怎么工作的了: 把 <code>filterText</code> 的值设置为 ‘ball’ ,然后刷新应用,你会看到数据列表被正确的更新了.</p>
<h2 id="第五步:_添加反向数据流">第五步: 添加反向数据流</h2><p>代码在jsfiddle上:<a href="https://jsfiddle.net/reactjs/n47gckhr/" target="_blank" rel="external">查看代码</a></p>
<p>目前为止,我们已经构建了一个通过props和状态,从上到下正确渲染出组件层级的应用了.是时候支持反向的数据流了:阶层底层的表单组件需要更新 <code>FilterableProductTable</code> 的状态.</p>
<p>React数据流很清晰,很好理解程序是怎么运行的,但是这比传统的双向数据绑定要多写一些代码.<br>React 还提供了一种名为 <code>ReactLink</code> 的扩展,它可以使得这种模式和双向数据绑定一样的方便,但是这篇文章的目的不是这个,所以我们还是让数据流保持清晰.</p>
<p>如果你尝试在这个版本的例子里输入内容或者点击checkbox,你会看到React忽略了你的输入.这是故意的,因为我们把 <code>input</code> 的 <code>value</code> 属性设置成了 <code>state</code> 的值,而 <code>state</code> 值是从 <code>FilterableProductTable</code> 传入的.</p>
<p>让我们考虑一下我们希望实现什么效果.我们希望确保每当用户修改表单内容的时候,把状态更新为用户的输入内容.由于组件应该只更新自己的状态,所以 <code>FilterableProductTable</code> 应该传递一个回调给 <code>SearchBar</code> ,每当状态需要更新的时候,触发这个回调.我们在 inputs 上添加 <code>onChange</code> 事件来监听它.所有通过 <code>FilterableProductTable</code> 传入的回调都会调用 <code>setState()</code> 方法来更新应用的状态.</p>
<p>虽然这听起来有点复杂,但其实只有几行代码.而且数据的整个流向过程十分清晰.</p>
<h2 id="以上就是本文的内容">以上就是本文的内容</h2><p>希望这篇文章能够给你一些启发,如何使用React来构建组件和应用.虽然它可能会让你比以前多写一些代码,但你要知道,读代码的时间要远远多于写代码的时间,而这样模块化,清晰的代码可读性是很强的.当你开始构建大型的组件库的时候,你会感谢它的清晰和模块化,另外,由于代码的可重用性很高,越写到后面你需要写代码也就越少了.</p>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/blog/">blog</a>
	</div>


      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-react-turorial" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/29/react-turorial/" class="article-date">
  	<time datetime="2015-12-29T02:47:19.000Z" itemprop="datePublished">2015-12-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/29/react-turorial/">react-教程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="教程">教程</h1><p>我们会创建一个简单却真实的评论列表,你可以把它用在博客里,就像Disqus,LiveFyre,FaceBook里的实时评论功能一样,但它只是一个基础的版本.</p>
<p>我们会提供:</p>
<ul>
<li>一个包含所有评论的视图</li>
<li>一个用于提交评论的表单</li>
<li>可以自定义后端接口的钩子</li>
</ul>
<p>它还有一些新特性:</p>
<ul>
<li><strong>预显示评论</strong>: 新增评论会在被保存到服务器之前就显示在页面里,以获得更快的体验.</li>
<li><strong>实时更新</strong>: 其他用户的评论会被实时的输出到评论视图里.</li>
<li><strong>支持Markdown格式</strong>: 用户可以使用markdown语法来书写评论内容.</li>
</ul>
<h3 id="想要跳过本文直接看源码?">想要跳过本文直接看源码?</h3><p><a href="https://github.com/reactjs/react-tutorial" target="_blank" rel="external">源码都放在了Github上</a></p>
<h3 id="启动服务端">启动服务端</h3><p>要开始这个教程,我们首先要启动一个服务端.我们只需要一个后端的API用来获取和保存数据.为了尽可能简化它,我们用脚本语言创建了一个简单的服务端,它刚好满足我们的需要.<strong>你可以<a href="https://github.com/reactjs/react-tutorial/" target="_blank" rel="external">查看源码</a>或者<a href="https://github.com/reactjs/react-tutorial/archive/master.zip" target="_blank" rel="external">下载zip压缩文件</a>,这里面包含了启动所需要的一切程序</strong>.</p>
<p>为了更简化,我们要运行的服务端使用了一个 <em>JSON</em> 格式的文件来作为数据库.在开发环境不可能这样做,但能让这个API更简单的模拟你的操作.一旦启动服务端,它就可以支持我们的后端API,满足静态页面的生成需要.</p>
<h3 id="开始">开始</h3><p>因为这只是个教程,所以我们尽可能的简化它. 在刚才讨论的服务端程序包里,有一个HTML页面,它就是我们要做的页面. 在你喜欢的编辑器里打开 <em>public/index.html</em> 页面. 它看起来应该像这样:</p>
<pre><code><span class="comment">&lt;!-- index.html --&gt;</span>
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>React Tutorial<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://cdnjs.cloudflare.com/ajax/libs/react/0.14.3/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"content"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/babel"</span> <span class="attribute">src</span>=<span class="value">"scripts/example.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/babel"</span>&gt;</span><span class="actionscript">
      <span class="comment">// To get started with this tutorial running your own code, simply remove</span>
      <span class="comment">// the script tag loading scripts/example.js and start writing code here.</span>
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><p>教程的剩下部分,会教你如何在script标签里写自己的javascript代码.我们没有使用高级的自动刷新功能,所以每次保存以后需要手动刷新浏览器来查看更新.启动服务器以后,在浏览器里打开 <em><a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></em> 来查看程序. 当你第一次打开这个它,还没有做过任何改动的时候,你可以看到完整的项目,这就是我们等下要做的.准备要开始学习,只需要把前面的 <em>script</em> 标签给删掉,然后就可以继续了.</p>
<blockquote>
<p><strong>注意:</strong> 为了等下方便发送ajax请求,我们在这里引入了jQuery,但React并不是强制使用jQuery才能工作的.</p>
<p>由于直接在html文件的script标签里写react的话,intelliJ不能识别JSX语法,所以最好还是写在外链的js文件里.</p>
</blockquote>
<h3 id="你的第一个组件">你的第一个组件</h3><p>React都是模块化的, 由可编辑的组件组成. 我们的这个评论框例子由以下这些组件构成:</p>
<pre><code>-<span class="ruby"> <span class="constant">CommentBox</span>
</span>  -<span class="ruby"> <span class="constant">CommentList</span>
</span>    -<span class="ruby"> <span class="constant">Comment</span>
</span>  -<span class="ruby"> <span class="constant">CommentForm</span></span>
</code></pre><p>让我们创建一个 CommentBox 组件,它只是一个简单的 <div> :</div></p>
<pre><code><span class="comment">// tutorial1.js</span>
<span class="keyword">var</span> CommentBox = React.createClass({
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentBox"</span>&gt;
        Hello, world! I am a CommentBox.
      &lt;/div&gt;
    );
  }
});
ReactDOM.render(
  &lt;CommentBox /&gt;,
  document.getElementById(<span class="string">'content'</span>)
);
</code></pre><p>注意,原生的HTML元素是以小写字母开头的,而自定义的React类名应该以大写字母开头.</p>
<h4 id="JSX_语法">JSX 语法</h4><p>首先要注意的是javascript里类似于XML的语法.它有一个简单的预编译机制,会把这个语法糖转换成纯javascript:</p>
<pre><code><span class="comment">// tutorial1-raw.js</span>
<span class="keyword">var</span> CommentBox = React.createClass({displayName: <span class="string">'CommentBox'</span>,
  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> (
      React.createElement(<span class="string">'div'</span>, {className: <span class="string">"commentBox"</span>},
        <span class="string">"Hello, world! I am a CommentBox."</span>
      )
    );
  }
});
ReactDOM.render(
  React.createElement(CommentBox, <span class="literal">null</span>),
  <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)
);
</code></pre><p>是否要使用JSX语法是可选的,但是使用它会比不使用要更简单.了解更多关于 <a href="https://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX语法</a></p>
<h4 id="继续下一步">继续下一步</h4><p>我们把一些方法放在一个Javscript对象里,然后把它传给 <code>React.createClass()</code> ,以创建一个React组件.这些方法里最重要的就是 <code>render</code> 方法,它返回了React组件树,最后会渲染成HTML.</p>
<p>这里的 <code>&lt;div&gt;</code> 标签并不是真正的DOM元素;他们是React <code>div</code> 组件的实例.你可以想象成他们是某种标记或数据,React知道要如何去处理他们.React是安全的,我们并不是生成HTML字符串,所以默认已经阻止了XSS攻击.</p>
<p>你不需要返回所有的HTML.你可以返回一个你(或别人)创建的组件树.这就使得React是可重用的.可重用化是构建可维护的前端的一个重要原则.</p>
<p><code>ReactDOM.render()</code> 实例化了根组件,开始构造组件内容,然后把内容注入到一个既存的原生DOM元素里.这个DOM元素可以通过第二个参数传入.</p>
<p><code>ReactDOM</code> 模块暴露的是DOM特有的方法,而 <code>React</code> 类有一些核心的工具是可以在不同的使用React的平台上共享的.(比如 <a href="http://facebook.github.io/react-native/" target="_blank" rel="external">React Native</a>)</p>
<p>很重要的一点是,可以在这个教程里看到, <code>ReactDOM.render</code> 方法是被放在script的最后调用的. <code>React.render</code> 只有在合成的组件被定义完成后才能被调用.</p>
<h2 id="创建组件">创建组件</h2><p>让我们继续创建 <code>CommentList</code> 和 <code>CommentForm</code> 的骨架,也是简单的 <code>&lt;div&gt;</code>. 把这两个组件加到你的文件里,声明 <code>CommentBox</code> 组件和调用 <code>ReactDOM.render</code> 部分的代码不变:</p>
<pre><code><span class="comment">// tutorial2.js</span>
<span class="keyword">var</span> CommentList = React.createClass({
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentList"</span>&gt;
        Hello, world! I am a CommentList.
      &lt;/div&gt;
    );
  }
});

<span class="keyword">var</span> CommentForm = React.createClass({
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentForm"</span>&gt;
        Hello, world! I am a CommentForm.
      &lt;/div&gt;
    );
  }
});
</code></pre><p>接下来,更新 <code>CommentBox</code> 组件的代码,使用新的组件:</p>
<pre><code><span class="comment">// tutorial3.js</span>
<span class="keyword">var</span> CommentBox = React.createClass({
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentBox"</span>&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre><p>注意我们是如何把HTML标签和我们创建的组件合在一起的.HTML组件只是普通的React组件,它和你自定义的组件只有一点不同.JSX编译机制会自动把HTML标签重写成 <code>React.createElement(tagName)</code> 表达式,其他都不变.这是为了防止污染全局命名空间.</p>
<h3 id="使用属性">使用属性</h3><p>让我们来创建 <code>Comment</code> 组件,它依赖于父组件传给它的数据. 从父组件传入的数据可以通过子组件的’属性’来获取. 这些’属性’可以通过 <code>this.props</code> 来访问. 使用属性,我们可以获取到 <code>CommentList</code> 传给 <code>Comment</code> 的数据,然后生成元素.</p>
<pre><code><span class="comment">// tutorial4.js</span>
<span class="keyword">var</span> Comment = React.createClass({
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"comment"</span>&gt;
        &lt;h2 className=<span class="string">"commentAuthor"</span>&gt;
          {<span class="keyword">this</span>.props.author}
        &lt;/h2&gt;
        {<span class="keyword">this</span>.props.children}
      &lt;/div&gt;
    );
  }
});
</code></pre><p>在JSX语法里(可以是属性,也可以是子组件),通过把一段Javascript表达式放在花括号里,可以插入文本或者在组件树里插入React组件.指定名字的属性值可以通过 <code>this.props</code> 对象中的对应的key来获取.嵌套的元素可以通过 <code>this.props.children</code> 来获取.</p>
<h3 id="组件的属性">组件的属性</h3><p>现在我们定义了 <code>Comment</code> 组件,接下来我们想要给它传入作者名字和评论内容.这允许我们重用每个评论的代码.现在,在我们的 CommentList 组件里添加一些评论:</p>
<pre><code><span class="comment">// tutorial5.js</span>
<span class="keyword">var</span> CommentList = React.createClass({
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentList"</span>&gt;
        &lt;Comment author=<span class="string">"Pete Hunt"</span>&gt;This <span class="keyword">is</span> one comment&lt;/Comment&gt;
        &lt;Comment author=<span class="string">"Jordan Walke"</span>&gt;This <span class="keyword">is</span> *another* comment&lt;/Comment&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre><p>现在,我们通过 <code>CommentList</code> 组件向它的子组件 <code>Comment</code> 传递了一些数据.举个栗子,我们传入了 ‘Pete Hunt’(通过一个属性) 以及 ‘This is one comment’(通过一个像XML格式一样的子节点) 给第一条 <code>Comment</code>. 就像前面提到的, <code>Comment</code>组件可以通过 <code>this.props.author</code> 以及 <code>this.props.children</code> 来获取到这些属性.</p>
<h3 id="添加Markdown支持">添加Markdown支持</h3><p>Markdown是一个简单的格式化文本的方法.举个栗子,用’*’包围的文字会变成强调部分(斜体).</p>
<p>在这个教程里,我们使用第三方的库 <strong>marked</strong> 来处理Markdown文本,把它们转换成原生HTML. 我们已经在页面里引入了这个库,可以直接用它了.让我们把内容通过Markdown转换然后输出它:</p>
<pre><code><span class="comment">// tutorial6.js</span>
<span class="keyword">var</span> Comment = React.createClass({
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"comment"</span>&gt;
        &lt;h2 className=<span class="string">"commentAuthor"</span>&gt;
          {<span class="keyword">this</span>.props.author}
        &lt;/h2&gt;
        {marked(<span class="keyword">this</span>.props.children.toString())}
      &lt;/div&gt;
    );
  }
});
</code></pre><p>我们这里所做的仅仅是调用了marked库,我们需要把被React封装过的 <code>this.props.children</code> 文本转换成原始的字符串,这样marked才能识别.所以我们明确的调用 <code>toString()</code>.</p>
<p>但这样做有个问题! 我们渲染出来的评论内容在浏览器里看上去是这样的: <code>&quot;&lt;p&gt;This is &lt;em&gt;another&lt;/em&gt; comment&lt;/p&gt;&quot;</code> .我们希望的是这些标签能够真正地被转换成HTML.</p>
<p>这是React保护你免受 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="external">XXS攻击</a>.有一个方法可以解决这个问题,但是框架会给你一个警告,叫你不要这样做:</p>
<pre><code><span class="comment">// tutorial7.js</span>
<span class="keyword">var</span> Comment = React.createClass({
  rawMarkup: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> rawMarkup = marked(<span class="keyword">this</span>.props.children.toString(), {sanitize: <span class="literal">true</span>});
    <span class="keyword">return</span> { __html: rawMarkup };
  },

  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"comment"</span>&gt;
        &lt;h2 className=<span class="string">"commentAuthor"</span>&gt;
          {<span class="keyword">this</span>.props.author}
        &lt;/h2&gt;
        &lt;span dangerouslySetInnerHTML={<span class="keyword">this</span>.rawMarkup()} /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre><p>这是一个特殊的API,有意让插入原始的HTML变得困难.但对于marked来说,刚好可以利用它的优势.</p>
<p><strong>注意</strong>: 要使用这个API,你就必须仰赖于marked是安全的. 在这里,我们传入 <code>sanitize:true</code> 来告诉marked,把所有的HTML标记进行转义,而不是直接输出HTML.</p>
<blockquote>
<p>解释一下:在你输入的内容是纯文字或者’*’等符号的时候,marked会把它转换成html文本,比如 <code>&lt;p&gt;123&lt;em&gt;456&lt;/em&gt;&lt;/p&gt;</code> ,这个时候,你希望这些标签能变成HTML标签,而不是文字,所以你可以使用React的 <code>dangerouslySetInnerHTML</code> ,但是如果用户本身在内容里输入了html文本,比如 ‘<a></a>‘ 这样,如果不在marked里面设置 <code>sanitize:true</code>,那么用户输入的这些html文本也会变成HTML标签,这样就不安全.所以需要开启 <code>sanitize:true</code> ,这样,首先marked会把用户输入的所有内容都转义成html文本,然后通过Markdown转换来把文本变成对应的HTML,最后React直接把HTML渲染.这样就确保了用户不能创建HTML插入,但是可以使用markdown所支持的语法.</p>
</blockquote>
<h3 id="连接数据模型">连接数据模型</h3><p>到目前为止,我们直接在源码里插入了评论内容.接下来,我们要用一堆JSON数据生成评论列表.到最后,数据应该从服务端获取,但现在我们还是把它写在源码里:</p>
<pre><code><span class="comment">// tutorial8.js</span>
var data = [
  {<span class="string">id:</span> <span class="number">1</span>, <span class="string">author:</span> <span class="string">"Pete Hunt"</span>, <span class="string">text:</span> <span class="string">"This is one comment"</span>},
  {<span class="string">id:</span> <span class="number">2</span>, <span class="string">author:</span> <span class="string">"Jordan Walke"</span>, <span class="string">text:</span> <span class="string">"This is *another* comment"</span>}
];
</code></pre><p>我们需要用模块化的方式把数据放到 <code>CommentList</code> 里. 修改 <code>CommentBox</code> 和 <code>ReactDOM.render()</code> 方法,通过props把数据传入 <code>CommentList</code>:</p>
<pre><code>// tutorial9.js
var CommentBox = React.createClass({
  render: function() {
    return (
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"commentBox"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Comments<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="title">CommentList</span> <span class="attribute">data</span>=<span class="value">{this.props.data}</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">CommentForm</span> /&gt;</span>
      <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    );
  }
});

ReactDOM.render(
  <span class="tag">&lt;<span class="title">CommentBox</span> <span class="attribute">data</span>=<span class="value">{data}</span> /&gt;</span>,
  document.getElementById('content')
);
</code></pre><p>现在,数据就可以在 <code>CommentList</code> 里获取到了,让我们动态的生成评论:</p>
<pre><code><span class="comment">// tutorial10.js</span>
<span class="keyword">var</span> CommentList = React.createClass({
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> commentNodes = <span class="keyword">this</span>.props.data.map(<span class="function"><span class="keyword">function</span><span class="params">(comment)</span> </span>{
      <span class="keyword">return</span> (
        &lt;Comment author={comment.author} key={comment.id}&gt;
          {comment.text}
        &lt;/Comment&gt;
      );
    });
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentList"</span>&gt;
        {commentNodes}
      &lt;/div&gt;
    );
  }
});
</code></pre><p>就系酱紫!</p>
<h3 id="从服务端获取数据">从服务端获取数据</h3><p>让我们把硬编码的数据换成从服务端获取的动态数据.我们把data属性移除,换成一个获取数据的url属性:</p>
<pre><code><span class="comment">// tutorial11.js</span>
ReactDOM.render(
  &lt;CommentBox url=<span class="string">"/api/comments"</span> /&gt;,
  <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)
);
</code></pre><p>这个组件和之前的组件不同,它必须重新渲染自己.这个组件在服务器没有返回数据之前是没有任何数据的,在得到数据的时候,他们需要渲染一些新的评论.</p>
<p>注意: 代码在这一步是不能运行的.</p>
<h3 id="响应式状态">响应式状态</h3><p>到目前为止,每个组件都会基于它的props属性渲染自己一次. <code>props</code> 是不可变的:他们是通过父组件传过来的,被父组件所’拥有’的.为了实现交互,我们引入可变的<strong>状态</strong>到组件里. <code>this.state</code> 是组件私有的,并且可以通过调用 <code>this.setState()</code> 来改变.当状态更新的时候,组件会重新渲染自己.</p>
<p><code>render()</code> 方法用声明式的写法来使用 <code>this.props</code> 和 <code>this.state</code> 功能. 所以它确保了视图总是和输入保持一致.</p>
<blockquote>
<p>所谓的声明式,就像css类名一样,只需要声明一个类名,对应的样式修改了,元素的样式也就改变了,这个概念用到这里就是说,<code>render()</code>方法里的<code>this.props</code>和<code>this.state</code>变化的时候,视图也会同步发生变化.</p>
</blockquote>
<p>当服务器获取到数据的时候,评论的内容会变成新获取的数据.让我们添加一个评论的数组作为 <code>CommentBox</code> 组件的状态:</p>
<pre><code><span class="comment">// tutorial12.js</span>
<span class="keyword">var</span> CommentBox = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> {data: []};
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentBox"</span>&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={<span class="keyword">this</span>.state.data} /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre><p><code>getInitialState()</code> 方法在组件的生命周期里只会被执行一次,用于设置组件的初始状态.</p>
<h4 id="更新状态">更新状态</h4><p>当组件第一次被创建后,我们想要通过GET请求从服务端去获取JSON数据,然后更新状态以映射最新获取的数据.我们使用jQuery向前面已经搭建好的服务器发送一个异步请求来获取我们需要的数据.数据已经被放在这个服务器端了(就是 <code>comments.json</code> 文件),所以当数据被获取后, <code>this.state.data</code> 看起来是这样的:</p>
<pre><code>[
  {<span class="string">"author"</span>: <span class="string">"Pete Hunt"</span>, <span class="string">"text"</span>: <span class="string">"This is one comment"</span>},
  {<span class="string">"author"</span>: <span class="string">"Jordan Walke"</span>, <span class="string">"text"</span>: <span class="string">"This is *another* comment"</span>}
]


<span class="comment">// tutorial13.js</span>
<span class="keyword">var</span> CommentBox = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> {data: []};
  },
  componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    $.ajax({
      url: <span class="keyword">this</span>.props.url,
      dataType: <span class="string">'json'</span>,
      cache: <span class="literal">false</span>,
      success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{
        <span class="keyword">this</span>.setState({data: data});
      }.bind(<span class="keyword">this</span>),
      error: <span class="function"><span class="keyword">function</span><span class="params">(xhr, status, err)</span> </span>{
        console.error(<span class="keyword">this</span>.props.url, status, err.toString());
      }.bind(<span class="keyword">this</span>)
    });
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentBox"</span>&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={<span class="keyword">this</span>.state.data} /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre><p>这里, <code>componentDidMount</code> 方法会在组件第一次渲染完成后被React自动调用.实现动态更新的关键是 <code>this.setState()</code> 方法. 我们用从服务器获取的最新数据来替换原来的评论数组,然后视图会自动更新自己.由于它是响应式的,还需要加一个小改动来实现实时更新.我们这里只使用简单的轮询,你也可以很容易的使用WebSockets或者其他的技术.</p>
<pre><code><span class="comment">// tutorial14.js</span>
<span class="keyword">var</span> CommentBox = React.createClass({
  loadCommentsFromServer: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    $.ajax({
      url: <span class="keyword">this</span>.props.url,
      dataType: <span class="string">'json'</span>,
      cache: <span class="literal">false</span>,
      success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{
        <span class="keyword">this</span>.setState({data: data});
      }.bind(<span class="keyword">this</span>),
      error: <span class="function"><span class="keyword">function</span><span class="params">(xhr, status, err)</span> </span>{
        console.error(<span class="keyword">this</span>.props.url, status, err.toString());
      }.bind(<span class="keyword">this</span>)
    });
  },
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> {data: []};
  },
  componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.loadCommentsFromServer();
    setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentBox"</span>&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={<span class="keyword">this</span>.state.data} /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  }
});

ReactDOM.render(
  &lt;CommentBox url=<span class="string">"/api/comments"</span> pollInterval={<span class="number">2000</span>} /&gt;,
  document.getElementById(<span class="string">'content'</span>)
);
</code></pre><p>这里所做的只是把AJAX部分的代码放到一个单独的方法里,然后在组件第一次渲染完毕后执行一次,然后再每隔2s执行一次.试着在浏览器里运行它,然后修改 <code>comment.json</code> 文件(在你启动的那个项目文件夹里); 在2s以内,改变就会被呈现出来!</p>
<h3 id="添加评论">添加评论</h3><p>现在可以开始创建表单了.我们的 <code>CommentForm</code> 组件需要用户输入名字和评论内容,然后向服务器发送请求来保存评论:</p>
<pre><code><span class="comment">// tutorial15.js</span>
<span class="keyword">var</span> CommentForm = React.createClass({
  render: function() {
    <span class="keyword">return</span> (
      &lt;<span class="keyword">form</span> className=<span class="string">"commentForm"</span>&gt;
        &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"Your name"</span> /&gt;
        &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"Say something..."</span> /&gt;
        &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"Post"</span> /&gt;
      &lt;/<span class="keyword">form</span>&gt;
    );
  }
});
</code></pre><h4 id="可控组件_(Controlled_components)">可控组件 (Controlled components)</h4><p>对于传统的DOM元素, <code>input</code> 元素渲染后由浏览器管理它的状态(就是渲染出的value值).所以,真正的DOM元素的状态和对应的组件的状态就不一样了. 视图和组件的状态不同,这可不是理想的状态. 在React里,组件的状态应该永远和视图同步,而不仅仅是在初始化的时候.</p>
<p>因此,我们使用 <code>this.state</code> 在用户打字的时候保存他们输入的内容. 我们定义一个初始的 <code>state</code> ,它有两个属性 <code>author</code> 和 <code>text</code> ,一开始他们的值都是空字符串.在的 <code>&lt;input&gt;</code> 元素里,我们把 <code>value</code> 值设置成组件的 <code>state</code> ,然后给它们添加一个 <code>onChange</code> 事件处理句柄. 这类 <code>value</code> 被设置过的 <code>&lt;input&gt;</code> 元素,被成为可控元素.了解更多关于可控元素请查看 <a href="https://facebook.github.io/react/docs/forms.html#controlled-components" target="_blank" rel="external">表单</a></p>
<pre><code><span class="comment">// tutorial16.js</span>
<span class="keyword">var</span> CommentForm = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> {author: <span class="string">''</span>, text: <span class="string">''</span>};
  },
  handleAuthorChange: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{
    <span class="keyword">this</span>.setState({author: e.target.value});
  },
  handleTextChange: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{
    <span class="keyword">this</span>.setState({text: e.target.value});
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;form className=<span class="string">"commentForm"</span>&gt;
        &lt;input
          type=<span class="string">"text"</span>
          placeholder=<span class="string">"Your name"</span>
          value={<span class="keyword">this</span>.state.author}
          onChange={<span class="keyword">this</span>.handleAuthorChange}
        /&gt;
        &lt;input
          type=<span class="string">"text"</span>
          placeholder=<span class="string">"Say something..."</span>
          value={<span class="keyword">this</span>.state.text}
          onChange={<span class="keyword">this</span>.handleTextChange}
        /&gt;
        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Post"</span> /&gt;
      &lt;/form&gt;
    );
  }
});
</code></pre><h4 id="事件">事件</h4><p>React使用驼峰命名法给组件添加事件处理句柄.我们给这里的两个 <code>&lt;input&gt;</code> 元素添加了 <code>onChange</code> 事件处理句柄.现在,当用户在这两个 <code>&lt;input&gt;</code> 元素里输入内容的时候, 对应的 <code>onChange</code> 回调就会触发,组件的 <code>state</code> 就会被改变. 然后, <code>input</code> 元素所渲染的value值会被更新,映射组件当前的 <code>state</code> 值.</p>
<h4 id="提交表单">提交表单</h4><p>让我们实现表单的交互.当用户提交表单的时候,我们应该清空它,然后提交一个请求到服务器,然后刷新评论列表.首先,让我们监听表单提交事件,然后清空它.</p>
<pre><code><span class="comment">// tutorial17.js</span>
<span class="keyword">var</span> CommentForm = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> {author: <span class="string">''</span>, text: <span class="string">''</span>};
  },
  handleAuthorChange: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{
    <span class="keyword">this</span>.setState({author: e.target.value});
  },
  handleTextChange: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{
    <span class="keyword">this</span>.setState({text: e.target.value});
  },
  handleSubmit: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{
    e.preventDefault();
    <span class="keyword">var</span> author = <span class="keyword">this</span>.state.author.trim();
    <span class="keyword">var</span> text = <span class="keyword">this</span>.state.text.trim();
    <span class="keyword">if</span> (!text || !author) {
      <span class="keyword">return</span>;
    }
    <span class="comment">// <span class="doctag">TODO:</span> send request to the server</span>
    <span class="keyword">this</span>.setState({author: <span class="string">''</span>, text: <span class="string">''</span>});
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;form className=<span class="string">"commentForm"</span> onSubmit={<span class="keyword">this</span>.handleSubmit}&gt;
        &lt;input
          type=<span class="string">"text"</span>
          placeholder=<span class="string">"Your name"</span>
          value={<span class="keyword">this</span>.state.author}
          onChange={<span class="keyword">this</span>.handleAuthorChange}
        /&gt;
        &lt;input
          type=<span class="string">"text"</span>
          placeholder=<span class="string">"Say something..."</span>
          value={<span class="keyword">this</span>.state.text}
          onChange={<span class="keyword">this</span>.handleTextChange}
        /&gt;
        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Post"</span> /&gt;
      &lt;/form&gt;
    );
  }
});
</code></pre><p>我们给表单添加一个 <code>onSubmit</code> 事件处理句柄,当里面的表单被提交,并且表单控件都通过验证时,清空表单.</p>
<p>在事件回调里执行 <code>preventDefault()</code> 来阻止浏览器的默认表单提交事件.</p>
<h4 id="回调作为属性">回调作为属性</h4><p>当用户提交新评论的时候,我们需要更新评论列表来把新增的评论显示出来.应该把这个逻辑放在 <code>CommentBox</code> 里,因为 <code>CommentBox</code> 的状态对应的就是评论列表.</p>
<p>我们需要把数据从子组件再传回到它的父组件.通过在父组件的 <code>render</code> 方法里传递一个回调(<code>handleCommentSubmit</code>)给子组件,绑定到子组件的 <code>handleCommentSubmit</code> 事件上.每当事件触发,回调就会被执行:</p>
<pre><code><span class="comment">// tutorial18.js</span>
<span class="keyword">var</span> CommentBox = React.createClass({
  loadCommentsFromServer: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    $.ajax({
      url: <span class="keyword">this</span>.props.url,
      dataType: <span class="string">'json'</span>,
      cache: <span class="literal">false</span>,
      success: <span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{
        <span class="keyword">this</span>.setState({data: data});
      }.bind(<span class="keyword">this</span>),
      error: <span class="function"><span class="keyword">function</span><span class="params">(xhr, status, err)</span> </span>{
        console.error(<span class="keyword">this</span>.props.url, status, err.toString());
      }.bind(<span class="keyword">this</span>)
    });
  },
  handleCommentSubmit: <span class="function"><span class="keyword">function</span><span class="params">(comment)</span> </span>{
    <span class="comment">// <span class="doctag">TODO:</span> submit to the server and refresh the list</span>
  },
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> {data: []};
  },
  componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.loadCommentsFromServer();
    setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;div className=<span class="string">"commentBox"</span>&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={<span class="keyword">this</span>.state.data} /&gt;
        &lt;CommentForm onCommentSubmit={<span class="keyword">this</span>.handleCommentSubmit} /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre><p>当用户提交表单的时候,在 <code>CommentForm</code> 里调用回调:</p>
<pre><code><span class="comment">// tutorial19.js</span>
<span class="keyword">var</span> CommentForm = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> {author: <span class="string">''</span>, text: <span class="string">''</span>};
  },
  handleAuthorChange: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{
    <span class="keyword">this</span>.setState({author: e.target.value});
  },
  handleTextChange: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{
    <span class="keyword">this</span>.setState({text: e.target.value});
  },
  handleSubmit: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{
    e.preventDefault();
    <span class="keyword">var</span> author = <span class="keyword">this</span>.state.author.trim();
    <span class="keyword">var</span> text = <span class="keyword">this</span>.state.text.trim();
    <span class="keyword">if</span> (!text || !author) {
      <span class="keyword">return</span>;
    }
    <span class="keyword">this</span>.props.onCommentSubmit({author: author, text: text});
    <span class="keyword">this</span>.setState({author: <span class="string">''</span>, text: <span class="string">''</span>});
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> (
      &lt;form className=<span class="string">"commentForm"</span> onSubmit={<span class="keyword">this</span>.handleSubmit}&gt;
        &lt;input
          type=<span class="string">"text"</span>
          placeholder=<span class="string">"Your name"</span>
          value={<span class="keyword">this</span>.state.author}
          onChange={<span class="keyword">this</span>.handleAuthorChange}
        /&gt;
        &lt;input
          type=<span class="string">"text"</span>
          placeholder=<span class="string">"Say something..."</span>
          value={<span class="keyword">this</span>.state.text}
          onChange={<span class="keyword">this</span>.handleTextChange}
        /&gt;
        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Post"</span> /&gt;
      &lt;/form&gt;
    );
  }
});
</code></pre><p>现在回调已经正确了,接下来只需要把请求发送到服务器然后更新列表:</p>
<pre><code><span class="comment">// tutorial20.js</span>
<span class="keyword">var</span> CommentBox = React.createClass({
  loadCommentsFromServer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    $.ajax({
      url: <span class="keyword">this</span>.props.url,
      dataType: <span class="string">'json'</span>,
      cache: <span class="literal">false</span>,
      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{
        <span class="keyword">this</span>.setState({data: data});
      }.bind(<span class="keyword">this</span>),
      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>{
        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());
      }.bind(<span class="keyword">this</span>)
    });
  },
  handleCommentSubmit: <span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>{
    $.ajax({
      url: <span class="keyword">this</span>.props.url,
      dataType: <span class="string">'json'</span>,
      type: <span class="string">'POST'</span>,
      data: comment,
      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{
        <span class="keyword">this</span>.setState({data: data});
      }.bind(<span class="keyword">this</span>),
      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>{
        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());
      }.bind(<span class="keyword">this</span>)
    });
  },
  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> {data: []};
  },
  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">this</span>.loadCommentsFromServer();
    setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);
  },
  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> (
      <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"commentBox"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Comments<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="title">CommentList</span> <span class="attribute">data</span>=<span class="value">{this.state.data}</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">CommentForm</span> <span class="attribute">onCommentSubmit</span>=<span class="value">{this.handleCommentSubmit}</span> /&gt;</span>
      <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    )</span>;
  }
});
</code></pre><h3 id="优化:乐观性更新">优化:乐观性更新</h3><p>现在这个应用的功能都已经完成了.但是需要等到评论成功发送到服务器以后才能看到列表更新,这样会比较慢,我们可以乐观的认为评论会提交成功,直接把它添加到列表里,这样可以让应用的体验更快一些.</p>
<pre><code><span class="comment">// tutorial21.js</span>
<span class="keyword">var</span> CommentBox = React.createClass({
  loadCommentsFromServer: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    $.ajax({
      url: <span class="keyword">this</span>.props.url,
      dataType: <span class="string">'json'</span>,
      cache: <span class="literal">false</span>,
      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{
        <span class="keyword">this</span>.setState({data: data});
      }.bind(<span class="keyword">this</span>),
      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>{
        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());
      }.bind(<span class="keyword">this</span>)
    });
  },
  handleCommentSubmit: <span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>{
    <span class="keyword">var</span> comments = <span class="keyword">this</span>.state.data;
    <span class="comment">// 乐观地给评论添加一个id.将来这个id会被服务器端生成的id替换.</span>
    <span class="comment">// 在生产环境下你可能不会使用 Date.now() 作为id,而是使用更合适更健壮的id体系.</span>
    comment.id = <span class="built_in">Date</span>.now();
    <span class="keyword">var</span> newComments = comments.concat([comment]);
    <span class="keyword">this</span>.setState({data: newComments});
    $.ajax({
      url: <span class="keyword">this</span>.props.url,
      dataType: <span class="string">'json'</span>,
      type: <span class="string">'POST'</span>,
      data: comment,
      success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{
        <span class="keyword">this</span>.setState({data: data});
      }.bind(<span class="keyword">this</span>),
      error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, status, err</span>) </span>{
        <span class="keyword">this</span>.setState({data: comments});
        <span class="built_in">console</span>.error(<span class="keyword">this</span>.props.url, status, err.toString());
      }.bind(<span class="keyword">this</span>)
    });
  },
  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> {data: []};
  },
  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">this</span>.loadCommentsFromServer();
    setInterval(<span class="keyword">this</span>.loadCommentsFromServer, <span class="keyword">this</span>.props.pollInterval);
  },
  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> (
      <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"commentBox"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Comments<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
        <span class="tag">&lt;<span class="title">CommentList</span> <span class="attribute">data</span>=<span class="value">{this.state.data}</span> /&gt;</span>
        <span class="tag">&lt;<span class="title">CommentForm</span> <span class="attribute">onCommentSubmit</span>=<span class="value">{this.handleCommentSubmit}</span> /&gt;</span>
      <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    )</span>;
  }
});
</code></pre><h3 id="恭喜!">恭喜!</h3><p>你已经通过一些简单的步骤搭建了一个评论功能. 想要知道更多<a href="https://facebook.github.io/react/docs/why-react.html" target="_blank" rel="external">为什么要使用React</a>? 深入了解<a href="https://facebook.github.io/react/docs/top-level-api.html" target="_blank" rel="external">API文档</a>,开始使用吧! Good luck!</p>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/blog/">blog</a>
	</div>


      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-ajax-caching" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/23/ajax-caching/" class="article-date">
  	<time datetime="2015-12-23T08:53:19.000Z" itemprop="datePublished">2015-12-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/23/ajax-caching/">关于ajax缓存的两个真相</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>翻自 <a href="https://blog.httpwatch.com/2009/08/07/ajax-caching-two-important-facts/" target="_blank" rel="external">Ajax Caching: Two Important Facts</a></p>
</blockquote>
<p>Ajax的调用和其它的HTTP请求一样,用于构建web页面. 然后由于它是动态的,人们常常忽略了缓存它的好处.</p>
<p><a href="http://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309/" target="_blank" rel="external"> &lt;&lt; High Performance Web Sites >></a>一书的<a href="http://stevesouders.com/hpws/rule-ajax.php" target="_blank" rel="external">第14条</a>说到:</p>
<p><strong>让ajax请求可以被缓存</strong></p>
<p><strong>确保你的ajax请求遵循高性能指导方针,尤其是要有一个设置未来过期时间的Expires头.</strong></p>
<hr>
<p>这篇文章剩下的部分会包含两个重要的真相,这会帮助你理解并高效的使用Ajax请求的缓存.</p>
<h2 id="真相1:Ajax的缓存和HTTP的缓存是一样的">真相1:Ajax的缓存和HTTP的缓存是一样的</h2><p>现代浏览器的HTTP和缓存机制比Ajax的XMLHttpRequest对象要差很多,所以它不认识也不关心Ajax请求.它仅仅是遵循普通的HTTP缓存规则,通过服务器返回的响应头来进行缓存.</p>
<p>如果你已经对 <a href="http://blog.httpwatch.com/2007/12/10/two-simple-rules-for-http-caching/" target="_blank" rel="external">HTTP缓存</a> 有了解,那么你可以把HTTP缓存的知识用对Ajax缓存的理解上. 他们只有一点不同的,就是设置响应头的方式会和普通文件不一样.</p>
<p>下面这些响应头可以让你的Ajax可缓存:</p>
<ul>
<li><strong>Expires:</strong> 这一项应该被设置成未来的某个合适的时间点,时间点的设置取决于内容变动的频繁程度.举个栗子,如果请求的是个库存数量,那么Expires的值可以是10秒以后.如果请求的是一个相片,那么Expires的值就可以久一点,因为它不会经常变动.Expires头可以让浏览器在一段时间内重用本地缓存数据,从而避免任何不必要的与服务器数据交互.</li>
<li><strong>Last-Modified:</strong> 设置这一项是一个很好的选择,通过它,浏览器在发送条件性GET请求的时候会使用请求头里的 <em>If-Modified-Since</em> 来检查本地缓存的内容.如果数据不需要更新,服务器会返回304响应状态.</li>
<li><strong>Cache-Control:</strong> 在合适的情况下,这个值应该被设置为 <em>Public</em> ,这样所有的中间代理和缓存都可以被保存并且与其他用户共享内容.在火狐里,它还支持<a href="">HTTPS请求的缓存</a></li>
</ul>
<p>当然,如果你使用POST方式发送Ajax是不能缓存的,因为POST请求永远不会被缓存.如果你的Ajax请求会产生其他作用(比如银行账户之间的转账),请使用POST请求.</p>
<p>我们设置了一个demo(这个demo已经不能看了ヽ（≧□≦）ノ)来阐明这些头信息是如何工作的. 在HttpWatch里,你可以看到我们在响应头信息里设置了以上三个响应头</p>
<p><img src="http://jinyanhuan.github.io/blogimages/20151223.01.png" alt="Ajax Caching Headers"></p>
<p>如果你规律的点击 ‘Ajax Update’ 按钮,时间的改变会趋向于每隔一分钟一次.因为Expires响应头被设置为未来的一分钟.在下面这张截图里你可以看到:重复的点击更新按钮时,Ajax请求会读取浏览器本地的缓存而不会产生网络活动(发送和传输栏的值都是0)</p>
<p><img src="http://jinyanhuan.github.io/blogimages/20151223.02.png" alt="Ajax Caching Headers"></p>
<p>最后一次1:06.531时刻的点击发送的Ajax请求产生了网络数据传输,因为缓存的数据已经超过了一分钟. 服务器返回200响应状态表示获取到了一份新的数据.</p>
<blockquote>
<p>猜测这个demo应该是一个按钮,每点击一次获取一次当前时间然后回现在页面上.</p>
</blockquote>
<h2 id="真相2:IE浏览器在Expires时间过期之前不会刷新通过Ajax获取的内容-">真相2:IE浏览器在Expires时间过期之前不会刷新通过Ajax获取的内容.</h2><p>有些时候,Ajax在页面加载的时候就被用来填充页面的某些部分(比如一个价格列表).它并不是通过用户的某个事件(比如点击某个按钮)触发的,而是在页面加载的时候就通过javascript来发送的.就好像Ajax请求和那些嵌入资源(比如js和css)是一样的.</p>
<p>如果你开发这样的页面,在刷新它的时候,很可能想要更新嵌入的Ajax请求内容.对于嵌入资源(CSS文件,图片等),浏览器会通过用户刷新的方式是F5(刷新)还是Ctrl+F5(强制刷新)来自动发送下列不同类型的请求:</p>
<ol>
<li>F5(刷新): 如果请求内容带有 <em>Last-Modified</em> 响应头,那么浏览器会发送条件性更新请求. 它使用 <em>If-Modified-Since</em> 请求头进行比较,这样服务器就可以返回304状态来避免传输不必要的数据.</li>
<li>Ctrl+F5(强制刷新): 告诉浏览器发送无条件更新请求,请求头的 <em>Cache-Control</em> 被设置为<em>‘no-cache’</em>.这告诉所有的中间代理和缓存:浏览器需要获取最新的版本,无论它是否已经被缓存.</li>
</ol>
<p>Firefox把这个刷新的方式传播到了那些在页面加载的时候就发送的Ajax请求上,把这些Ajax请求当成嵌入资源来处理.下面是HttpWatch在火狐下的截图,显示了Ajax Caching demo(这个demo已经不能看了ヽ（≧□≦）ノ)刷新(F5)页面时Ajax请求的效果:</p>
<p><img src="http://jinyanhuan.github.io/blogimages/20151223.03.png" alt="Refresh of Ajax Request in Firefox"></p>
<p>火狐确保Ajax发起的请求是条件性的.在这个例子里,如果缓存数据不到10秒,服务器返回304,超过10秒,服务器返回200,重新传送数据.</p>
<p>在ie里,加载页面时就发起的Ajax请求被看做是和页面其他部分刷新毫无关系的,也不会被用户的刷新方式所左右.如果缓存的ajax数据没有过期,就不会有GET请求发送到服务器.它会直接从缓存里读取数据,从HttpWatch里看就是(Cache)结果.下面这个图是在ie下缓存没有过期的情况下按F5刷新:</p>
<p><img src="http://jinyanhuan.github.io/blogimages/20151223.04.png" alt="IE Refresh of Ajax Request"></p>
<p>就算是通过 Ctrl+F5 强制刷新,通过Ajax获取的数据也是从缓存里读取:</p>
<p><img src="http://jinyanhuan.github.io/blogimages/20151223.05.png" alt="IE Refresh of Ajax Request"></p>
<p>这就意味着,任何通过Ajax得到的内容如果没有过期,在ie下都不会被更新 - 即使你使用Ctrl+F5强制刷新. 唯一能确保你获取最新数据的方法就是手动清楚缓存. 可以使用HttpWatch的工具栏:</p>
<p><img src="http://jinyanhuan.github.io/blogimages/20151223.06.png" alt="IE Forced Refresh"></p>
<blockquote>
<p>注意,Cache结果和304结果是不同的.Cache其实是200(cache),304就是304.Cache其实没有向服务器发送请求,可以从chrome里看到,它的耗时是0,response也是空.而304不同,<br>304请求是浏览器发起了一个条件性的请求,这个请求携带了 <em>If-Modified-Since</em> 请求头,如果这个文件在浏览器发送的这个时间之后没有修改过,服务器端就回返回一个304状态,告诉浏览器使用它本地的缓存内容.它没有Cache快,因为请求还是发送到了服务器端,只不过服务器端没有发送数据.<br>可以看下taobao首页,里面既有200(cache)也有304.可以查看他们的区别.</p>
</blockquote>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ajax/">ajax</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/blog/">blog</a>
	</div>


      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-browserify-handbook" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/01/browserify-handbook/" class="article-date">
  	<time datetime="2015-11-01T07:08:19.000Z" itemprop="datePublished">2015-11-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/01/browserify-handbook/">browserify handbook</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>browserify handbook</p>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
      

      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 code_bunny
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>