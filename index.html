<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>code_bunny&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="never giveup reading!">
<meta property="og:type" content="website">
<meta property="og:title" content="code_bunny's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="code_bunny's blog">
<meta property="og:description" content="never giveup reading!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="code_bunny's blog">
<meta name="twitter:description" content="never giveup reading!">
  
    <link rel="alternative" href="/atom.xml" title="code_bunny&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="https://avatars1.githubusercontent.com/u/11350373?v=3&amp;s=460">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">code_bunny</a></h1>
		</hgroup>

		
		<p class="header-subtitle">never giveup reading!</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/OOP-Code-Bunny/" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/p/1005052438739075/home" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/encoding/" style="font-size: 10px;">encoding</a> <a href="/tags/es5/" style="font-size: 15px;">es5</a> <a href="/tags/es6/" style="font-size: 17.5px;">es6</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/grunt/" style="font-size: 10px;">grunt</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/less/" style="font-size: 10px;">less</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/react/" style="font-size: 12.5px;">react</a> <a href="/tags/sass/" style="font-size: 10px;">sass</a> <a href="/tags/unicode/" style="font-size: 10px;">unicode</a> <a href="/tags/utf-16/" style="font-size: 10px;">utf-16</a> <a href="/tags/webstorm/" style="font-size: 12.5px;">webstorm</a> <a href="/tags/前端工程化/" style="font-size: 10px;">前端工程化</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/OOP-Code-Bunny/">我的github</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/a5635268/">周孝刚</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://kingarthas37.github.io/">王麟</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/zhengyin/">郑印</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">虽然咸鱼翻身还是咸鱼,但至少可以变得好吃一点</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">code_bunny</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://avatars1.githubusercontent.com/u/11350373?v=3&amp;s=460">
				<hgroup>
				  <h1 class="header-author">code_bunny</h1>
				</hgroup>
			</div>
			
			<p class="header-subtitle">never giveup reading!</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/OOP-Code-Bunny/" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/p/1005052438739075/home" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-charCodeAt-and-codePointAt" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/25/charCodeAt-and-codePointAt/" class="article-date">
  	<time datetime="2016-02-25T07:46:18.000Z" itemprop="datePublished">2016-02-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/25/charCodeAt-and-codePointAt/">charCodeAt() and codePointAt()</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这篇文章主要介绍javascript里的<code>charCodeAt()</code>方法和ES6引进的<code>codePointAt()</code>方法.</p>
<p>在说这两个方法之前,必须要先补充一些关于Unicode编码的知识…</p>
<p>ASCII码是256(2^8)个(0-255)数字,每一个数字都是一个码点(code point)[1].用于代表256个字符.但是这256个字符只是常用字符,各国语言,包括中文,远远超过这个范围.所以Unicode就出现了,Unicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。</p>
<p>可以这么理解,Unicode码是ASCII码的一个超集(superset).它的前128个code point和ASCII是一致的.后面又增加了很多很多字符.而UTF-32,UTF-8,UTF-16,都是Unicode码的编码形式:</p>
<p><strong>UTF-32</strong><br>用固定长度的四个字节来表示每个码点,就算有些字符只需要一个字节,也通过把空缺位添加0来强制转换成8个字节.由于四个字节有32-bit,所以称为UTF-32编码.由于太浪费空间,比ASCII编码文件要大四倍,所以不能使用.</p>
<p><strong>UTF-8</strong><br>用可变长度的字节来表示每个码点,如果只需要一个字节就能表示的,就用一个字节,一个不够,就用两个…所以,在UTF-8编码下,一个字符有可能由1-4个字节组成.</p>
<p><strong>UTF-16</strong><br>结合了固定长度和可变长度,它只有两个字节和四个字节两种方式来表示码点.如果是两个字节,那么码点的范围应该是（U+0000到U+FFFF）,如果是四个字节,那么码点的范围应该是（U+010000到U+10FFFF）.<br>但是注意,我们不能直接使用 <em>U+010000</em> 这样的形式(应该是因为位数不同所以不能…),所以,四个字节的码点需要使用两个 <em>code unit</em> [2],来组成一个 <em>surrogate pair</em> [3]. 其中第一个code unit的范围是从 <em>0xD800</em> 到 <em>0xDBFF</em>,被成为高位(high surrogate)或头位(lead surrogate),第二个code unit的范围是从 <em>0xDC00</em> 到 <em>0xDFFF</em>,被称为低位(low surrogate)或尾位(trail surrogate).</p>
<p>好了,有了以上的这些知识,就可以看看 <code>charCodeAt()</code> 和 <code>codePointAt()</code>了.</p>
<h2 id="charCodeAt()">charCodeAt()</h2><p><code>charCodeAt()</code>方法返回一个0-65535的整数,这个数代表了指定索引位置的UTF-16 code unit的码点.(UTF-16 code unit匹配的码点有两种可能,一种是这个码点本身可以代表一个字符,另一种是,这个code unit可能是一组 surrogate pair 里的一个code unit,它的码点本身不代表任何字符,比如 Unicode码点范围 &gt; 0x10000 的那些).如果你需要的是整个 surrogate pair 的码点值,请使用 <code>codePointAt*()</code> 方法.</p>
<h3 id="语法">语法</h3><pre><code>str.<span class="function"><span class="title">charCodeAt</span><span class="params">(index)</span></span>
</code></pre><h4 id="参数">参数</h4><p><strong>index</strong></p>
<p>一个大于等于0,小于字符串长度的整数; 如果它不是一个数字,默认为0.</p>
<h3 id="描述">描述</h3><p>Unicode 码点的范围是 0-1114111 (0x10FFFF). 最前面的128个Unicode码点和ASCII码指向的字符完全相同.</p>
<p>注意, <code>charCodeAt()</code> 总是返回一个小于65536的值,这是因为,大于65536的码点会使用两个小于65536的’surrogate’伪字符来组成一个真实字符.因此,为了检查或重现这类字符的整个码点(大于等于65536),不仅需要使用 <code>charCodeAt(i)</code> 来检索,还需要使用 <code>charCodeAt(i+1)</code>,这就好像通过两个字母来检查重现一个字符串那样. 或者也可以使用 <code>codePointAt(i)</code>. 查看下面的例子2和3.</p>
<p>如果索引值小于0或者大于等于字符串的长度,<code>charCodeAt()</code> 返回 <code>NaN</code>.</p>
<blockquote>
<p>注意,字符串的长度并不一定是你看到的字符的长度,有些中文字,比如<a href="http://www.zdic.net/z/87/wy/20BB7.htm" target="_blank" rel="external">‘ji’</a>,虽然只有一个字,但它的length是2.它就是Unicode码点大于等于65536的一个例子.</p>
</blockquote>
<p>向下兼容: 在历史版本(比如JavaScript 1.2), charCodeAt() 方法返回对应索引位置字符指向 <em>ISO-Lation-1</em> 字符集的一个数字. <em>ISO-Latin-1</em> 字符集的范围是 0 到255.其中0-127直接映射ASCII码.</p>
<h3 id="例子">例子</h3><h4 id="使用_charCodeAt()">使用 charCodeAt()</h4><p>下面这个例子返回65, ‘A’的Unicode码点.</p>
<pre><code><span class="variable">'ABC</span><span class="variable">'.charCodeAt</span><span class="list">(<span class="keyword">0</span>)</span><span class="comment">; // returns 65</span>
</code></pre><h4 id="改造charCodeAt()来处理当一开始并不知道非基本平面字符(non-Basic-Multilingual-Plane)_[4]的高位在哪个位置出现的情况:">改造charCodeAt()来处理当一开始并不知道非基本平面字符(non-Basic-Multilingual-Plane) [4]的高位在哪个位置出现的情况:</h4><p>这个版本可以用在循环或者类似的场景:一开始并不知道是否有非基本平面字符存在于指定的索引位置前.</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fixedCharCodeAt</span>(<span class="params">str, idx</span>) </span>{
  <span class="comment">// ex. fixedCharCodeAt('\uD800\uDC00', 0); // 65536</span>
  <span class="comment">// ex. fixedCharCodeAt('\uD800\uDC00', 1); // false</span>
  idx = idx || <span class="number">0</span>;
  <span class="keyword">var</span> code = str.charCodeAt(idx);
  <span class="keyword">var</span> hi, low;

  <span class="comment">// 如果索引位置是一个高位 (可以把后面的十六进制改成0xDB7F来把高位当成一个单独的字符)</span>
  <span class="keyword">if</span> (<span class="number">0xD800</span> &lt;= code &amp;&amp; code &lt;= <span class="number">0xDBFF</span>) {
    hi = code;
    low = str.charCodeAt(idx + <span class="number">1</span>);
    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(low)) {
      <span class="keyword">throw</span> <span class="string">'High surrogate not followed by low surrogate in fixedCharCodeAt()'</span>;
    }
    <span class="keyword">return</span> ((hi - <span class="number">0xD800</span>) * <span class="number">0x400</span>) + (low - <span class="number">0xDC00</span>) + <span class="number">0x10000</span>;
  }
  <span class="keyword">if</span> (<span class="number">0xDC00</span> &lt;= code &amp;&amp; code &lt;= <span class="number">0xDFFF</span>) { <span class="comment">// 低位</span>
    <span class="comment">// 返回false以跳出循环的本次迭代,因为在上次迭代时,遇到和它配对的那个高位时,已经处理过它了(处理的过程就是注释掉的那段)</span>
    <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="comment">/*hi = str.charCodeAt(idx - 1);
    low = code;
    return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;*/</span>
  }
  <span class="keyword">return</span> code;
}
</code></pre><h4 id="改造charCodeAt()来处理当一开始就已经知道非基本平面字符(non-Basic-Multilingual-Plane)_[4]的高位在哪个位置出现的情况:">改造charCodeAt()来处理当一开始就已经知道非基本平面字符(non-Basic-Multilingual-Plane) [4]的高位在哪个位置出现的情况:</h4><pre><code><span class="function"><span class="keyword">function</span> <span class="title">knownCharCodeAt</span>(<span class="params">str, idx</span>) </span>{
  str += <span class="string">''</span>;
  <span class="keyword">var</span> code,
      end = str.length;

  <span class="keyword">var</span> surrogatePairs = <span class="regexp">/[\uD800-\uDBFF][\uDC00-\uDFFF]/g</span>;
  <span class="keyword">while</span> ((surrogatePairs.exec(str)) != <span class="literal">null</span>) {
    <span class="keyword">var</span> li = surrogatePairs.lastIndex;
    <span class="keyword">if</span> (li - <span class="number">2</span> &lt; idx) {
      idx++;
    }
    <span class="keyword">else</span> {
      <span class="keyword">break</span>;
    }
  }

  <span class="keyword">if</span> (idx &gt;= end || idx &lt; <span class="number">0</span>) {
    <span class="keyword">return</span> <span class="literal">NaN</span>;
  }

  code = str.charCodeAt(idx);

  <span class="keyword">var</span> hi, low;
  <span class="keyword">if</span> (<span class="number">0xD800</span> &lt;= code &amp;&amp; code &lt;= <span class="number">0xDBFF</span>) {
    hi = code;
    low = str.charCodeAt(idx + <span class="number">1</span>);
    <span class="comment">// Go one further, since one of the "characters" is part of a surrogate pair</span>
    <span class="keyword">return</span> ((hi - <span class="number">0xD800</span>) * <span class="number">0x400</span>) + (low - <span class="number">0xDC00</span>) + <span class="number">0x10000</span>;
  }
  <span class="keyword">return</span> code;
}
</code></pre><h2 id="codePointAt()">codePointAt()</h2><p><code>codePointAt()</code>方法返回一个Unicode码点值,它是一个非负整数,</p>
<h3 id="语法-1">语法</h3><pre><code>str.<span class="function"><span class="title">codePointAt</span><span class="params">(pos)</span></span>
</code></pre><h4 id="参数-1">参数</h4><p><strong>pos</strong></p>
<p>指定从字符串里获取Unicode码点的索引位置.</p>
<h3 id="描述-1">描述</h3><p>如果在指定的位置没有元素,返回undefined.如果指定位置没有 UTF-16 surrogate pair, 返回指定位置的 code unit 的码点.</p>
<h3 id="栗子">栗子</h3><pre><code><span class="string">'ABC'</span>.codePointAt(<span class="number">1</span>);          <span class="comment">// 非UTF-16 surrogate pair ,返回A的Unicode码点: 66</span>
<span class="string">'\uD800\uDC00'</span>.codePointAt(<span class="number">0</span>); <span class="comment">// UTF-16 surrogate pair 返回整个字符的码点: 65536</span>

<span class="string">'XYZ'</span>.codePointAt(<span class="number">42</span>);         <span class="comment">// undefined</span>
</code></pre><h3 id="兼容低版本浏览器(Polyfill)">兼容低版本浏览器(Polyfill)</h3><p>下面的扩展允许你在原本不支持这个方法的低版本的浏览器中像支持ES6一样的使用codePointAt()方法.</p>
<pre><code><span class="comment">/*! http://mths.be/codepointat v0.1.0 by @mathias */</span>
<span class="keyword">if</span> (!<span class="built_in">String</span>.prototype.codePointAt) {
  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
<span class="pi">    'use strict'</span>; <span class="comment">// needed to support `apply`/`call` with `undefined`/`null`</span>
    <span class="keyword">var</span> codePointAt = <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>{
      <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) {
        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();
      }
      <span class="keyword">var</span> string = <span class="built_in">String</span>(<span class="keyword">this</span>);
      <span class="keyword">var</span> size = string.length;
      <span class="comment">// `ToInteger`</span>
      <span class="keyword">var</span> index = position ? <span class="built_in">Number</span>(position) : <span class="number">0</span>;
      <span class="keyword">if</span> (index != index) { <span class="comment">// better `isNaN`</span>
        index = <span class="number">0</span>;
      }
      <span class="comment">// Account for out-of-bounds indices:</span>
      <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {
        <span class="keyword">return</span> <span class="literal">undefined</span>;
      }
      <span class="comment">// Get the first code unit</span>
      <span class="keyword">var</span> first = string.charCodeAt(index);
      <span class="keyword">var</span> second;
      <span class="keyword">if</span> ( <span class="comment">// check if it’s the start of a surrogate pair</span>
        first &gt;= <span class="number">0xD800</span> &amp;&amp; first &lt;= <span class="number">0xDBFF</span> &amp;&amp; <span class="comment">// high surrogate</span>
        size &gt; index + <span class="number">1</span> <span class="comment">// there is a next code unit</span>
      ) {
        second = string.charCodeAt(index + <span class="number">1</span>);
        <span class="keyword">if</span> (second &gt;= <span class="number">0xDC00</span> &amp;&amp; second &lt;= <span class="number">0xDFFF</span>) { <span class="comment">// low surrogate</span>
          <span class="comment">// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae</span>
          <span class="keyword">return</span> (first - <span class="number">0xD800</span>) * <span class="number">0x400</span> + second - <span class="number">0xDC00</span> + <span class="number">0x10000</span>;
        }
      }
      <span class="keyword">return</span> first;
    };
    <span class="keyword">if</span> (<span class="built_in">Object</span>.defineProperty) {
      <span class="built_in">Object</span>.defineProperty(<span class="built_in">String</span>.prototype, <span class="string">'codePointAt'</span>, {
        <span class="string">'value'</span>: codePointAt,
        <span class="string">'configurable'</span>: <span class="literal">true</span>,
        <span class="string">'writable'</span>: <span class="literal">true</span>
      });
    } <span class="keyword">else</span> {
      <span class="built_in">String</span>.prototype.codePointAt = codePointAt;
    }
  }());
}
</code></pre><h2 id="总结">总结</h2><p>上面关于<code>charCodeAt()</code>和<code>codePointAt()</code>的详解分别来自于:<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt" target="_blank" rel="external">charCodeAt()</a>以及<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt" target="_blank" rel="external">codePointAt()</a>;</p>
<p>这里面有几个重点:</p>
<ol>
<li>Unicode 码点,基本多语言平面(Basic-Multilingual-Plane)只支持0-65535的码点,每个字符占用两个字节,对应一个码点,超过这个范围的码点,需要使用四个字节,两个 code unit,, 一个高位(U+D800到U+DBFF),一个低位(U+DC00到U+DFFF),他们组成一个 surrogate pair,代表一个字符.</li>
<li>charCodeAt() 方法只返回对应位置的code unit对应的码点.不管这个码点是不是代表了一个字符,不管这个code unit是独立的字符还是 surrogate pair 的一部分.</li>
<li>codePointAt() 方法返回对应位置的code unit 或 surrogate pair的码点: 遇到独立能代表字符的码点,就返回它; 遇到 surrogate pair 里的高位 code unit,就返回整个 surrogate pair 的码点; 遇到 surrogate pair 里的低位 code unit,也返回这个 code unit 对应的码点(虽然它不配合任何字符).</li>
<li>文章中多次用到一个公式,就是已知 surrogate pair 的高位 code unit 的码点和低位 code unit 的码点,如何求得整个 surrogate pair 的码点,这个公式来自于<a href="http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae" target="_blank" rel="external">surrogate-formulae</a></li>
</ol>
<p>最后,再给出一个综合例子,帮助理解:<a href="https://jsfiddle.net/caqmpasb/1/" target="_blank" rel="external">online site</a></p>
<pre><code>console.<span class="built_in">log</span>(<span class="string">'\uD800\uDC00'</span>.charCodeAt(<span class="number">0</span>)); <span class="comment"> //55296  </span>
console.<span class="built_in">log</span>(<span class="string">'\uD800\uDC00'</span>.charCodeAt(<span class="number">1</span>)); <span class="comment"> //56320  </span>
console.<span class="built_in">log</span>(<span class="string">'\uD800\uDC00'</span>.codePointAt(<span class="number">0</span>));<span class="comment"> //65536  获取的是整个 surrogate pair 的码点</span>
console.<span class="built_in">log</span>(<span class="string">'\uD800\uDC00'</span>.codePointAt(<span class="number">1</span>));<span class="comment"> //56320  获取的是'\uDC00'的码点, 同charCodeAt()   </span>
console.<span class="built_in">log</span>(<span class="string">'\uD800'</span>.codePointAt(<span class="number">0</span>));      <span class="comment"> //55296  获取的是'\uD800'的码点, 同charCodeAt()</span>

<span class="comment">
//根据阮一峰老师的文章:"当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。"</span><span class="comment">
//所以,'\uD800\uDC00'应该两个码点一起解读,解读的结果就是65536</span>

console.<span class="built_in">log</span>(<span class="string">'𠮷'</span>.<span class="built_in">length</span>); <span class="comment"> //2</span>
console.<span class="built_in">log</span>(<span class="string">'𠮷'</span>.codePointAt(<span class="number">0</span>)); <span class="comment"> //134071 </span>
console.<span class="built_in">log</span>(<span class="string">'𠮷'</span>.codePointAt(<span class="number">1</span>)); <span class="comment"> //57271</span>
<span class="comment">
//𠮷(ji)这个字,是由两个码点,四个字节组成的,所以它的length是2.两个码点一起解读,得到的结果就是134071</span>
<span class="comment">
//最后一点,当获取这类需要两个码点一起解读组成一个字符的时候,如果获取高位的code point,它得到的会是整个字符的Unicode值,但如果获取低位的code point,它得到的依然是第二个码点的Unicode值.</span>
</code></pre><hr>
<p>[1]:<em>code point(码点)</em> Unicode里的码点,有几种表达方式,比如 ‘©’ 符号,它的码点是 <em>U+00A9</em> 或 <em>0xA9</em> 或 <em>\u00A9</em> 或十进制的 <em>169</em><br>其中 <em>\u00A9</em> 是js字符串里使用的方法, <em>0xA9</em> 是写js的时候使用的方法, <em>169</em> 最容易理解,就是一一对应的数字嘛,和ASCII的0-255数字一样,每个数字代表一个码点.</p>
<hr>
<p>[2]:<em>code unit</em> 不知道中文应该翻译成啥,编码单元? 在UTF-16编码方式时,如果是一个四字节的字符,比如上面一个土,下面一个口,念<a href="http://www.zdic.net/z/87/wy/20BB7.htm" target="_blank" rel="external">‘ji’</a>的那个字,它的Unicode码点是 <em>U+20BB7</em>,变成两个字节以后应该是 <em>\uD842\uDFB7</em> .在UTF-16编码里,需要由两个字节组成的字符,其中的每个字节就称为一个 <em>code unit</em> ,两个 <em>code unit</em> 组成一个 <em>surrogate pair</em>.  </p>
<hr>
<p>[3]:<em>surrogate pair</em> 不知道中文翻译成啥. 在UTF-16编码里,如有四个字节,两个 <em>code unit</em> 组成的字符,它就被称为 surrogate pair </p>
<hr>
<p>[4]:<em>Basic-Multilingual-Plane</em> 基本多语言平面. Unicode码点是由多个平面组成的,每个平面存放65536(2^16)个码点,其中第一个平面被称为 基本多语言平面 或者 BMP. 它包含了从 U+0000 到 U+FFFF 的码点,这些是各国最常用的字符.</p>
<hr>
<p>其他参考:<a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="external">阮一峰老师写的Unicode资料</a></p>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/encoding/">encoding</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unicode/">unicode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/utf-16/">utf-16</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/blog/">blog</a>
	</div>


      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-method-definations" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/18/method-definations/" class="article-date">
  	<time datetime="2016-02-18T02:16:41.000Z" itemprop="datePublished">2016-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/18/method-definations/">method definitions</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从ECMAScript2015(ES6)开始,引入了一种在初始化对象的时候,给对象定义方法的简约语法.为原来给一个函数定义一个方法名的键值对语法提供了一种简写语法.</p>
<h2 id="语法">语法</h2><pre><code>var obj = {
  property( parameters… ) {},
  *generator( parameters… ) {},
// also with computed keys:
  [<span class="link_label">property</span>](<span class="link_url"> parameters… </span>) {},
  *[<span class="link_label">generator</span>](<span class="link_url"> parameters… </span>) {},
// compare ES5 getter/setter syntax:
  get property() {},
  set property(value) {}
};
</code></pre><h2 id="描述">描述</h2><p>这种简写的语法类似于ES5引入的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="external">setter</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" target="_blank" rel="external">getter</a>语法</p>
<p>比如下面的代码:</p>
<pre><code><span class="keyword">var</span> obj = {
  foo: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{},
  bar: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{}
};
</code></pre><p>现在你可以把他们简写成这样:</p>
<pre><code>var obj = {
  foo(){},
  bar(){}     
};
</code></pre><p>简写generator方法:</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="external">Generator methods</a>也可以使用简写的语法.但是要注意,’<em>‘必须在属性名的前面,就是说 `</em> g(){}<code>是正确的,而</code>g *(){}` 是不对的.</p>
<pre><code><span class="comment">// 使用一个属性名+函数 (ES6之前)</span>
<span class="keyword">var</span> obj2 = {
  g: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>{
    <span class="keyword">var</span> index = <span class="number">0</span>;
    <span class="keyword">while</span>(<span class="literal">true</span>)
      <span class="keyword">yield</span> index++;
  }
};

<span class="comment">// 同一个对象,使用简洁语法</span>
<span class="keyword">var</span> obj2 = { 
  * g() {
    <span class="keyword">var</span> index = <span class="number">0</span>;
    <span class="keyword">while</span>(<span class="literal">true</span>)
      <span class="keyword">yield</span> index++;
  }
};

<span class="keyword">var</span> it = obj2.g();
<span class="built_in">console</span>.log(it.next().value); <span class="comment">// 0</span>
<span class="built_in">console</span>.log(it.next().value); <span class="comment">// 1</span>
</code></pre><h3 id="方法定义不是构造函数:">方法定义不是构造函数:</h3><p>方法定义的结果不是构造函数,尝试实例化它会返回一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError" target="_blank" rel="external">Type</a>; </p>
<pre><code><span class="keyword">var</span> obj = { 
  <span class="keyword">method</span>() {},
};
new obj.<span class="keyword">method</span>; // <span class="type">TypeError</span>: obj.<span class="keyword">method</span> <span class="keyword">is</span> <span class="keyword">not</span> a constructor

<span class="keyword">var</span> obj = { 
  * g() {} 
};
new obj.g; // <span class="type">TypeError</span>: obj.g <span class="keyword">is</span> <span class="keyword">not</span> a constructor (changed <span class="keyword">in</span> <span class="type">ES2016</span>)
</code></pre><h2 id="栗子">栗子</h2><h3 id="简单的场景">简单的场景</h3><pre><code><span class="keyword">var</span> obj={
    a:<span class="string">'foo'</span>,
    b(){<span class="keyword">return</span> <span class="keyword">this</span>.a}
}
<span class="built_in">console</span>.log(obj.b());    <span class="comment">//'foo'</span>
</code></pre><h3 id="计算后的属性名">计算后的属性名</h3><p>简洁语法也支持计算后的属性名</p>
<pre><code>var bar = {
  foo0 : function (){<span class="keyword">return</span> <span class="number">0</span>;},
  foo1(){<span class="keyword">return</span> <span class="number">1</span>;},
  [<span class="string">"foo"</span> + <span class="number">2</span>](){<span class="keyword">return</span> <span class="number">2</span>;},
};

console.<span class="built_in">log</span>(bar.foo0()); <span class="comment">// 0</span>
console.<span class="built_in">log</span>(bar.foo1()); <span class="comment">// 1</span>
console.<span class="built_in">log</span>(bar.foo2()); <span class="comment">// 2</span>
</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" target="_blank" rel="external">原文地址</a></p>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/blog/">blog</a>
	</div>


      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-function-asterisk" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/16/function-asterisk/" class="article-date">
  	<time datetime="2016-02-16T08:47:47.000Z" itemprop="datePublished">2016-02-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/16/function-asterisk/">function asterisk</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>function*</strong>声明(<code>function</code> 关键字加上一个星号)定义一个生成器函数,返回一个生成器(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">Generator</a>)对象.</p>
<p>你还可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction" target="_blank" rel="external">GeneratorFunction</a>构造函数以及<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function*" target="_blank" rel="external">function* expression</a>来定义生成器函数.</p>
<h2 id="语法">语法</h2><pre><code>function* <span class="built_in">name</span>([<span class="built_in">param</span>[, <span class="built_in">param</span>[, ... <span class="built_in">param</span>]]]) {
    statements
}
</code></pre><p><strong>name</strong></p>
<p>函数的名字</p>
<p><strong>param</strong></p>
<p>传递给函数的参数的名字.一个函数最多可以带有255个参数.</p>
<p><strong>statements</strong></p>
<p>statements由函数体组成.</p>
<h2 id="描述">描述</h2><p>Generators 是可以退出和再次进入的函数.它的上下文(变量的绑定)在整个重新进入的过程中一直会被保存.</p>
<p>调用一个generator函数,并不会立刻执行函数体;而是返回一个函数的迭代器(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator" target="_blank" rel="external">iterator</a>).<br>每当调用迭代器的 <code>next()</code> 方法时,generator的函数体就会被执行,直到它遇到第一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" target="_blank" rel="external">yield</a>表达式. 它指定了迭代器的返回值,如果使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*" target="_blank" rel="external">yield*</a>,则代理到另一个generator函数. <code>next()</code>方法返回一个对象,对象的 <code>value</code> 属性的值是 <code>yield</code> 表达式的值; <code>done</code> 属性的值表明该generator是否已经执行完了全部的yield. 详见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next" target="_blank" rel="external">Generator.prototype.next()</a>.<br>当调用迭代器的 <code>return(param)</code> 方法时,Generator被关闭,返回参数 <code>param</code> 的值,详见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return" target="_blank" rel="external">Generator.prototype.return()</a> </p>
<h2 id="栗子">栗子</h2><h3 id="简单的栗子">简单的栗子</h3><pre><code>function* idMaker(){
  <span class="keyword">var</span> index = 0;
  <span class="keyword">while</span>(index &lt; 3)
    yield index++;
}

<span class="keyword">var</span> <span class="keyword">gen</span> = idMaker();

console.<span class="literal">log</span>(<span class="keyword">gen</span>.next().value); <span class="comment">// 0</span>
console.<span class="literal">log</span>(<span class="keyword">gen</span>.next().value); <span class="comment">// 1</span>
console.<span class="literal">log</span>(<span class="keyword">gen</span>.next().done);  <span class="comment">// false</span>
console.<span class="literal">log</span>(<span class="keyword">gen</span>.next().value); <span class="comment">// 2</span>
console.<span class="literal">log</span>(<span class="keyword">gen</span>.next().done);  <span class="comment">// true</span>
console.<span class="literal">log</span>(<span class="keyword">gen</span>.next().value); <span class="comment">// undefined</span>
</code></pre><h3 id="使用_yield*_的栗子">使用 <code>yield*</code> 的栗子</h3><pre><code><span class="function"><span class="keyword">function</span>* <span class="title">anotherGenerator</span>(<span class="params">i</span>) </span>{
  <span class="keyword">yield</span> i + <span class="number">1</span>;
  <span class="keyword">yield</span> i + <span class="number">2</span>;
  <span class="keyword">yield</span> i + <span class="number">3</span>;
}

<span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>)</span>{
  <span class="keyword">yield</span> i;
  <span class="keyword">yield</span>* anotherGenerator(i);
  <span class="keyword">yield</span> i + <span class="number">10</span>;
}

<span class="keyword">var</span> gen = generator(<span class="number">10</span>);

<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 10</span>
<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 11</span>
<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 12</span>
<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 13</span>
<span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 20</span>
</code></pre><blockquote>
<p>这里需要注意,使用yield*返回的代理迭代器拥有自己的闭包环境,两个i不是同一个i,如果把另一个参数换成a,可能更清晰一点…</p>
</blockquote>
<h3 id="生成器不是构造函数">生成器不是构造函数</h3><p>下面这样做是不行的:</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>{}
<span class="keyword">var</span> obj = <span class="keyword">new</span> f; <span class="comment">// throws "TypeError: f is not a constructor"</span>
</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="external">原文地址</a> </p>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/blog/">blog</a>
	</div>


      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-setter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/16/setter/" class="article-date">
  	<time datetime="2016-02-16T03:45:01.000Z" itemprop="datePublished">2016-02-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/16/setter/">setter</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>set</strong>语法把对象的某个属性绑定到一个函数上,当<strong>设置</strong>该属性的时候执行这个函数</p>
<h2 id="语法">语法</h2><pre><code><span class="collection">{set prop<span class="list">(<span class="keyword"><span class="built_in">val</span></span>)</span> <span class="collection">{ . . . }</span>}</span>
<span class="collection">{set <span class="collection">[expression]</span><span class="list">(<span class="keyword"><span class="built_in">val</span></span>)</span> <span class="collection">{ . . . }</span>}</span>
</code></pre><h3 id="参数">参数</h3><p><strong>prop</strong></p>
<p>需要绑定到函数的属性名</p>
<p><strong>val</strong></p>
<p>一个变量的别名,它的值就是想要赋值给 <code>prop</code> 属性的值.</p>
<p><strong>表达式</strong></p>
<p>从ECMAScript 6 开始,你可以使用一个表达式来得到一个计算后的属性名来绑定所给的函数.</p>
<p><strong>描述</strong></p>
<p>在JavaScript里,一个setter可以实现当指定的属性试图被改变的时候执行一个函数.Setter通常和getter结合使用来创建一个伪状态.属性的setter不能给该属性一个确定的属性值.</p>
<p>使用 <code>set</code> 的时候需要注意一下几点:</p>
<ul>
<li>它可以拥有一个id,id可以是数字也可以是字符串</li>
<li>它必须拥有一个参数.不能少也不能多(<a href="http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/" target="_blank" rel="external">查看更多</a>)</li>
<li>在对象字面量里,一个属性只能有一个setter,并且setter绑定函数的属性不能再指定它的值,反之亦然.({ set x(v) { }, set x(v) { } } and { x: …, set x(v) { } } 类似于这样的是不行的.)</li>
</ul>
<p>setter可以通过 <code>delete</code> 方法删除</p>
<h2 id="栗子">栗子</h2><h3 id="在对象初始化的时候给属性添加setter">在对象初始化的时候给属性添加setter</h3><p>这会给 <code>o</code> 对象添加一个名为 <code>current</code> 的伪属性,每当它被分配属性值的时候, <code>log</code> 属性会被更新,被分配的属性值会被记录.</p>
<pre><code>var o = {
  <span class="function"><span class="built_in">set</span> <span class="title">current</span> <span class="params">(str)</span> </span>{
    <span class="keyword">this</span>.<span class="built_in">log</span>[<span class="keyword">this</span>.<span class="built_in">log</span>.length] = str;
  },
  <span class="built_in">log</span>: []
}

console.<span class="built_in">log</span>(o.current);
o.current = <span class="number">1</span>;
console.<span class="built_in">log</span>(o.<span class="built_in">log</span>);
o.current = <span class="number">2</span>;
console.<span class="built_in">log</span>(o.<span class="built_in">log</span>);
</code></pre><p>注意,current属性并没有被定义,试图访问它会得到undefined.Note that current is not defined and any attempts to access it will result in undefined.</p>
<h3 id="使用_delete_操作来删除setter">使用 <code>delete</code> 操作来删除setter</h3><p>如果你想把setter删除,只需要使用 <code>delete</code> 就行了.</p>
<pre><code><span class="operator"><span class="keyword">delete</span> o.<span class="keyword">current</span>;</span>
</code></pre><h3 id="使用_defineProperty_给一个既存的对象添加setter">使用 <code>defineProperty</code> 给一个既存的对象添加setter</h3><p>想要在任何时间给一个既存的对象添加setter ,可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty()</a></p>
<pre><code><span class="keyword">var</span> o = { a:<span class="number">0</span> };

<span class="built_in">Object</span>.defineProperty(o, <span class="string">"b"</span>, { set: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>{ <span class="keyword">this</span>.a = x / <span class="number">2</span>; } });

o.b = <span class="number">10</span>; <span class="comment">// Runs the setter, which assigns 10 / 2 (5) to the 'a' property</span>
<span class="built_in">console</span>.log(o.a) <span class="comment">// 5</span>
</code></pre><h3 id="使用计算后的属性名">使用计算后的属性名</h3><blockquote>
<p>注意: 计算后的属性名属于试验中技术, ECMAScript 6 的目标的一部分, 还没有被浏览器广泛支持. 在不支持的环境下会触发语法错误.<br>(经过测试,在目前的chrome里是可以用的.)</p>
</blockquote>
<pre><code><span class="keyword">var</span> expr = <span class="string">"foo"</span>;

<span class="keyword">var</span> obj = {
  baz: <span class="string">"bar"</span>,
  <span class="keyword">set</span> [expr](v) { <span class="keyword">this</span>.baz = v; }
};

<span class="built_in">console</span>.log(obj.baz); <span class="comment">// "bar"</span>
obj.foo = <span class="string">"baz"</span>;      <span class="comment">// run the setter</span>
<span class="built_in">console</span>.log(obj.baz); <span class="comment">// "baz"</span>
</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="external">查看原文</a></p>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es5/">es5</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/blog/">blog</a>
	</div>


      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-getter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/15/getter/" class="article-date">
  	<time datetime="2016-02-15T09:55:47.000Z" itemprop="datePublished">2016-02-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/15/getter/">getter</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>get</strong>语法把对象的某个属性绑定到一个函数上,当<strong>访问</strong>该属性的时候执行这个函数</p>
<h2 id="语法">语法</h2><pre><code>{get prop() { ... } }
{get [<span class="link_label">expression</span>](<span class="link_url"></span>) { ... } }
</code></pre><h3 id="参数">参数</h3><p><strong>prop</strong></p>
<p>需要绑定到函数的属性名</p>
<p><strong>表达式</strong></p>
<p>从ECMAScript 6 开始,你可以使用一个表达式来得到一个计算后的属性名来绑定所给的函数.</p>
<h2 id="描述">描述</h2><p>有时候,你会想要让属性值是一个动态计算出的值,或者映射一个外部变量的状态而不需要显式地调用一个方法.在JavaScript里,你可以通过getter来实现它. 同一个对象的同一个属性不能同时绑定getter函数并且指定拥有一个值,但可以通过结合使用getter和setter来创建一个伪属性.</p>
<p>使用getter的时候需要注意以下几点:</p>
<ul>
<li>它可以拥有一个id,id可以是数字也可以是字符串</li>
<li>它不能拥有参数.一个也不能有.(<a href="http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/" target="_blank" rel="external">查看更多</a>)</li>
<li>在对象字面量里,一个属性只能有一个getter,并且getter绑定函数的属性不能再指定它的值,反之亦然.({ get x() { }, get x() { } } and { x: …, get x() { } } 类似于这样的是不行的.)</li>
</ul>
<p>getter可以通过 <code>delete</code> 方法删除</p>
<h2 id="栗子">栗子</h2><h3 id="在对象初始化的时候给属性添加getter">在对象初始化的时候给属性添加getter</h3><p>这会给 <code>ocj</code> 对象创建一个名为 <code>latest</code> 的伪属性,在打印它的时候会返回数组的最后一个值.</p>
<pre><code>var <span class="keyword">log</span> = [<span class="string">'test'</span>];
var obj = {
  get latest () {
    <span class="keyword">if</span> (<span class="keyword">log</span>.<span class="keyword">length</span> == <span class="number">0</span>) <span class="keyword">return</span> undefined;
    <span class="keyword">return</span> <span class="keyword">log</span>[<span class="keyword">log</span>.<span class="keyword">length</span> - <span class="number">1</span>]
  }
}
console.<span class="keyword">log</span> (obj.latest); <span class="regexp">//</span> Will <span class="keyword">return</span> <span class="string">"test"</span>.
</code></pre><p>注意,重新给 <code>latest</code> 属性指定值不会生效:</p>
<pre><code>var <span class="keyword">log</span> = [<span class="string">'test'</span>];
var obj = {
  get latest () {
    <span class="keyword">if</span> (<span class="keyword">log</span>.<span class="keyword">length</span> == <span class="number">0</span>) <span class="keyword">return</span> undefined;
    <span class="keyword">return</span> <span class="keyword">log</span>[<span class="keyword">log</span>.<span class="keyword">length</span> - <span class="number">1</span>]
  }
}
console.<span class="keyword">log</span> (obj.latest); <span class="regexp">//</span> Will <span class="keyword">return</span> <span class="string">"test"</span>.
<span class="keyword">log</span>.<span class="keyword">push</span>(<span class="string">'bunny'</span>);
console.<span class="keyword">log</span>(obj.latest);  <span class="regexp">//</span> Will <span class="keyword">return</span> <span class="string">"bunny"</span>
obj.latest = <span class="number">3</span>;
console.<span class="keyword">log</span>(obj.latest);  <span class="regexp">//</span> Will <span class="keyword">return</span> <span class="string">"bunny"</span> still
</code></pre><h3 id="使用_delete_操作来删除getter">使用 <code>delete</code> 操作来删除getter</h3><p>如果你想把getter删除,只需要使用 <code>delete</code> 就行了.</p>
<pre><code><span class="operator"><span class="keyword">delete</span> obj.latest;</span>
</code></pre><h3 id="使用_defineProperty_给一个既存的对象添加getter">使用 <code>defineProperty</code> 给一个既存的对象添加getter</h3><p>想要在任何时间给一个既存的对象添加getter ,可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty()</a></p>
<pre><code><span class="keyword">var</span> o = { a:<span class="number">0</span> }

<span class="built_in">Object</span>.defineProperty(o, <span class="string">"b"</span>, { get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>; } });

<span class="built_in">console</span>.log(o.b) <span class="comment">// Runs the getter, which yields a + 1 (which is 1)</span>
</code></pre><h3 id="使用计算后的属性名">使用计算后的属性名</h3><blockquote>
<p>注意: 计算后的属性名属于试验中技术, ECMAScript 6 的目标的一部分, 还没有被浏览器广泛支持. 在不支持的环境下会触发语法错误.<br>(经过测试,在目前的chrome里是可以用的.)</p>
</blockquote>
<pre><code>var expr = "foo";

var obj = {
  get [<span class="link_label">expr</span>](<span class="link_url"></span>) { return "bar"; }
};

console.log(obj.foo); // "bar"
</code></pre><h3 id="智能_/_重写自身_/_懒getter">智能 / 重写自身 / 懒getter</h3><p>getter提供了一种定义对象属性的方式,但是它的值要到获取属性值的时候才会被计算. 也就是说, getter会延迟计算属性值,直到需要用到这个值,所以如果这个值一直用不到,则永远不需要为计算它而付出开销.</p>
<p>另外一个对getter进行额外优化的技术方案是: 智能getters 或 <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="external">制表</a>getters. 它可以延迟计算属性值,并且把计算结果进行缓存,让之后的访问直接获取缓存结果. 属性值会在第一次访问时进行计算并缓存,然后之后的访问会直接读取缓存结果而不是再次计算.这在以下场景下是很实用的:</p>
<ul>
<li>如果计算一个属性值会花费很多代价(占取很多随机内容,消耗CPU时间,产生大量工作线程,检索远程文件,等)</li>
<li>属性值目前暂时不会用到,而是之后才会用到,甚至一直都用不到.</li>
<li>如果它要被多次使用到,但是这个值不会变化,每次都不需要重新计算,甚至不能重新计算.</li>
</ul>
<p>也就是说,如果某个属性值是可能会变化的,你就不能使用懒getter,因为它不会重新计算值.</p>
<p>在下面的这个例子里,对象有一个getter作为它的notifier属性,在获取属性的时候,这个属性被删除后再次添加,但新增属性所拥有的就是普通的属性值.最后这个值被返回.</p>
<pre><code><span class="keyword">get</span> notifier() {
  <span class="keyword">delete</span> <span class="keyword">this</span>.notifier;
  <span class="keyword">return</span> <span class="keyword">this</span>.notifier = <span class="built_in">document</span>.getElementById(<span class="string">"bookmarked-notification-anchor"</span>);
},
</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="external">查看原文</a></p>

        
          <!-- show an end symbol if the article is fully displayed -->
          <hr/>
          <p class="article-more-link">
            <a>end</a>
          </p>
        
      
    </div>
    
    <div class="article-info">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es5/">es5</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/blog/">blog</a>
	</div>


      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 code_bunny
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>